下面是阶段 6 的目录和文件：

portfolio/
  __init__.py
  models.py
  runner.py
  example_config.py

cli/
  run_portfolio_backtest.py
  run_portfolio_live_replay.py


我按文件给你代码；你直接把它们放进对应路径就可以。

1. portfolio/models.py — 组合配置的数据结构
# portfolio/models.py
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import date
from typing import Any, Dict, List, Optional


@dataclass
class StrategyInstanceConfig:
    """
    单个策略实例的配置（对应 “某只股票 + 某个策略 + 一组参数”）。

    示例：
        StrategyInstanceConfig(
            name="abu_key_level",
            ts_code="000001.SZ",
            initial_cash=100_000,
            strategy_params={"min_signal_score": 60.0},
        )
    """
    name: str                     # 策略名，对应 StrategyRegistry 里的 key，如 "abu_key_level"
    ts_code: str                  # 标的代码
    initial_cash: float = 100_000.0
    strategy_params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PortfolioConfig:
    """
    组合级配置：包含多个策略实例，外加全局起止日期等信息。

    - instances: 策略实例列表
    - start_date / end_date: 回测/回放日期区间
    """
    name: str
    instances: List[StrategyInstanceConfig]
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    meta: Dict[str, Any] = field(default_factory=dict)


if __name__ == "__main__":
    # 简单自测：构造一个组合配置并打印
    from datetime import date as _date

    cfg = PortfolioConfig(
        name="demo_portfolio",
        instances=[
            StrategyInstanceConfig(
                name="abu_key_level",
                ts_code="000001.SZ",
                initial_cash=100_000,
                strategy_params={"min_signal_score": 60.0},
            )
        ],
        start_date=_date(2024, 1, 1),
        end_date=_date(2024, 1, 31),
    )

    print("PortfolioConfig self-test:")
    print(cfg)

2. portfolio/runner.py — 组合回测 & 组合仿真实盘调度
# portfolio/runner.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import date, timedelta
from typing import Any, Dict, Iterable, List, Optional

import pandas as pd

from portfolio.models import PortfolioConfig, StrategyInstanceConfig
from backtest.engine import TickBacktester, BacktestResult
from live.live_engine import LiveEngine
from live.broker_qmt import QmtBroker
from live.broker_base import DummyBroker, BrokerBase
from factors import AbuPriceLevelProvider
from microstructure import AbuMicrostructureAnalyzer
from strategy.registry import StrategyRegistry


@dataclass
class PortfolioBacktestResult:
    """
    组合级回测结果：包含每个实例的 BacktestResult 和简单汇总。
    """
    portfolio_name: str
    start_date: date
    end_date: date
    instance_results: Dict[str, BacktestResult]  # key = ts_code or instance_id

    def to_equity_dataframe(self) -> pd.DataFrame:
        """
        把每个实例的 initial/final equity 整理成一个 DataFrame，便于在 UI 中展示。
        """
        rows = []
        for key, r in self.instance_results.items():
            rows.append(
                {
                    "key": key,
                    "ts_code": r.ts_code,
                    "start_date": r.start_date,
                    "end_date": r.end_date,
                    "initial_cash": r.initial_cash,
                    "final_equity": r.final_equity,
                    "total_pnl": r.total_pnl,
                    "trade_count": r.trade_count,
                }
            )
        if not rows:
            return pd.DataFrame(
                columns=[
                    "key",
                    "ts_code",
                    "start_date",
                    "end_date",
                    "initial_cash",
                    "final_equity",
                    "total_pnl",
                    "trade_count",
                ]
            )
        return pd.DataFrame(rows)


class PortfolioBacktestRunner:
    """
    组合级回测调度器。

    当前版本：
        - 按组合配置，对每个 StrategyInstanceConfig 启动一个 TickBacktester；
        - 暂时串行执行（多进程可以作为后续优化）；
        - 回测引擎内部使用 AbuKeyLevelStrategy。
    """

    def __init__(self, cfg: PortfolioConfig) -> None:
        self.cfg = cfg

    def _build_date_range(self, start: date, end: date) -> List[date]:
        cur = start
        out: List[date] = []
        while cur <= end:
            out.append(cur)
            cur = cur + timedelta(days=1)
        return out

    def run(self) -> PortfolioBacktestResult:
        if self.cfg.start_date is None or self.cfg.end_date is None:
            raise ValueError("PortfolioConfig.start_date / end_date 不能为空")

        trade_dates = self._build_date_range(self.cfg.start_date, self.cfg.end_date)
        results: Dict[str, BacktestResult] = {}

        for inst in self.cfg.instances:
            print(
                f"[PortfolioBacktestRunner] run backtest for "
                f"{inst.ts_code} with initial_cash={inst.initial_cash}"
            )
            # TickBacktester 当前是单标的回测引擎
            bt = TickBacktester(
                ts_code=inst.ts_code,
                initial_cash=inst.initial_cash,
            )
            result = bt.run(
                trade_dates=trade_dates,
                strategy_config=inst.strategy_params,
            )
            key = f"{inst.name}:{inst.ts_code}"
            results[key] = result

        return PortfolioBacktestResult(
            portfolio_name=self.cfg.name,
            start_date=self.cfg.start_date,
            end_date=self.cfg.end_date,
            instance_results=results,
        )


class PortfolioLiveReplayRunner:
    """
    组合级仿真实盘（使用 LiveEngine + QmtBroker(dry_run)）。

    - 使用 TickStoreSource 读取 tick，作为“实时”喂给策略；
    - 每个实例一个 LiveEngine，与对应 broker 绑定；
    - 当前版本同样是串行回放（可以后续优化为并行）。
    """

    def __init__(
        self,
        cfg: PortfolioConfig,
        broker_factory: Optional[callable] = None,
        strategy_registry: Optional[StrategyRegistry] = None,
    ) -> None:
        self.cfg = cfg
        self.registry = strategy_registry or StrategyRegistry()
        # broker_factory 用来创建 Broker 实例，默认用 QmtBroker(dry_run=True)
        self.broker_factory = broker_factory or (lambda: QmtBroker(dry_run=True, config={"initial_cash": 1_000_000}))
        self._engines: Dict[str, LiveEngine] = {}

    def _build_date_range(self, start: date, end: date) -> List[date]:
        cur = start
        out: List[date] = []
        while cur <= end:
            out.append(cur)
            cur = cur + timedelta(days=1)
        return out

    def _ensure_engines(self) -> None:
        """
        根据组合配置构建 LiveEngine 实例，仅构建一次。
        """
        if self._engines:
            return

        for inst in self.cfg.instances:
            # 1. 构建 Broker（当前为 QmtBroker(dry_run=True) 或 DummyBroker）
            broker: BrokerBase = self.broker_factory()

            # 2. 构建策略。当前 registry 只内置 "abu_key_level"
            plp = AbuPriceLevelProvider()
            micro = AbuMicrostructureAnalyzer()
            # 这里不用 registry.create，是因为现阶段只有 abu 策略；
            # 将来你扩展 registry 后，可以改为从 registry 动态创建。
            strategy = self.registry.create(
                "abu_key_level",
                ts_code=inst.ts_code,
                price_level_provider=plp,
                micro_analyzer=micro,
                config=inst.strategy_params,
            )

            # 3. 构建 LiveEngine
            engine = LiveEngine(
                strategy=strategy,
                broker=broker,
            )
            key = f"{inst.name}:{inst.ts_code}"
            self._engines[key] = engine
            print(f"[PortfolioLiveReplayRunner] engine created for {key}")

    def run_replay(self) -> Dict[str, pd.DataFrame]:
        """
        按组合配置的日期区间，对每个实例执行 tick 回放。

        返回：
            {key: orders_df}，key = "strategy_name:ts_code"
        """
        if self.cfg.start_date is None or self.cfg.end_date is None:
            raise ValueError("PortfolioConfig.start_date / end_date 不能为空")

        self._ensure_engines()
        trade_dates = self._build_date_range(self.cfg.start_date, self.cfg.end_date)

        all_orders: Dict[str, pd.DataFrame] = {}
        for key, engine in self._engines.items():
            ts_code = key.split(":", 1)[1]
            print(f"[PortfolioLiveReplayRunner] run replay for {key}")
            df_orders = engine.run_replay(ts_code=ts_code, trade_dates=trade_dates)
            all_orders[key] = df_orders

        return all_orders


if __name__ == "__main__":
    # 简单自测：构造一个组合配置，分别跑 backtest + live replay（前提：本地有 tick 数据）
    from datetime import date as _date
    from portfolio.models import StrategyInstanceConfig, PortfolioConfig

    cfg = PortfolioConfig(
        name="demo_portfolio",
        instances=[
            StrategyInstanceConfig(
                name="abu_key_level",
                ts_code="000001.SZ",
                initial_cash=100_000,
                strategy_params={"min_signal_score": 60.0},
            ),
            StrategyInstanceConfig(
                name="abu_key_level",
                ts_code="000002.SZ",
                initial_cash=200_000,
                strategy_params={"min_signal_score": 65.0},
            ),
        ],
        start_date=_date(2024, 1, 2),
        end_date=_date(2024, 1, 5),
    )

    print("=== PortfolioBacktestRunner self-test ===")
    bt_runner = PortfolioBacktestRunner(cfg)
    try:
        bt_result = bt_runner.run()
        print(bt_result.to_equity_dataframe())
    except FileNotFoundError as e:
        print("Backtest self-test: tick data missing, skip details.", e)

    print("=== PortfolioLiveReplayRunner self-test ===")
    live_runner = PortfolioLiveReplayRunner(cfg)
    try:
        orders_dict = live_runner.run_replay()
        for k, df in orders_dict.items():
            print(f"orders for {k}:")
            print(df.head())
    except FileNotFoundError as e:
        print("Live replay self-test: tick data missing, skip details.", e)

3. portfolio/example_config.py — 一个可直接改的组合配置示例
# portfolio/example_config.py
from __future__ import annotations

from datetime import date
from portfolio.models import PortfolioConfig, StrategyInstanceConfig

"""
示例：一个简单的组合配置文件。

实际使用时，你可以：
    - 复制本文件为自己的 my_portfolio.py；
    - 修改 stocks / 日期 / 策略参数；
    - 在 cli 脚本中 import 使用。
"""

EXAMPLE_PORTFOLIO_CONFIG = PortfolioConfig(
    name="example_abu_portfolio",
    instances=[
        StrategyInstanceConfig(
            name="abu_key_level",
            ts_code="000001.SZ",
            initial_cash=100_000,
            strategy_params={
                "min_signal_score": 60.0,
                "risk_per_trade_pct": 0.01,
                "max_position_pct": 0.3,
            },
        ),
        StrategyInstanceConfig(
            name="abu_key_level",
            ts_code="000002.SZ",
            initial_cash=150_000,
            strategy_params={
                "min_signal_score": 65.0,
                "risk_per_trade_pct": 0.008,
                "max_position_pct": 0.25,
            },
        ),
    ],
    start_date=date(2024, 1, 2),
    end_date=date(2024, 1, 10),
    meta={
        "description": "示例组合：两只股票跑阿布关键位策略",
    },
)


if __name__ == "__main__":
    print("EXAMPLE_PORTFOLIO_CONFIG:")
    print(EXAMPLE_PORTFOLIO_CONFIG)

4. portfolio/__init__.py
# portfolio/__init__.py
"""
组合级调度模块入口。

包含：
- StrategyInstanceConfig / PortfolioConfig
- PortfolioBacktestRunner / PortfolioBacktestResult
- PortfolioLiveReplayRunner
"""

from .models import StrategyInstanceConfig, PortfolioConfig
from .runner import (
    PortfolioBacktestRunner,
    PortfolioBacktestResult,
    PortfolioLiveReplayRunner,
)

__all__ = [
    "StrategyInstanceConfig",
    "PortfolioConfig",
    "PortfolioBacktestRunner",
    "PortfolioBacktestResult",
    "PortfolioLiveReplayRunner",
]


if __name__ == "__main__":
    print("portfolio package exports:", __all__)

5. cli/run_portfolio_backtest.py — 命令行回测入口
# cli/run_portfolio_backtest.py
from __future__ import annotations

"""
组合回测命令行入口。

用法示例（在项目根目录）：
    python -m cli.run_portfolio_backtest

你可以在文件内修改默认使用的 PortfolioConfig，也可以改为从命令行参数/环境变量选择不同配置文件。
"""

import argparse
from pathlib import Path

import pandas as pd

from portfolio.example_config import EXAMPLE_PORTFOLIO_CONFIG
from portfolio.runner import PortfolioBacktestRunner


def main() -> None:
    parser = argparse.ArgumentParser(description="Run portfolio backtest.")
    parser.add_argument(
        "--output",
        type=str,
        default="portfolio_backtest_result.csv",
        help="回测结果导出路径（CSV）",
    )
    args = parser.parse_args()

    cfg = EXAMPLE_PORTFOLIO_CONFIG  # 这里你可以替换为自己的组合配置

    print(f"[cli] Start portfolio backtest: {cfg.name}")
    runner = PortfolioBacktestRunner(cfg)

    try:
        result = runner.run()
    except FileNotFoundError as e:
        print("[cli] Tick data missing, please确保已完成数据下载 & tick 文件落盘。")
        print("Error:", e)
        return

    df = result.to_equity_dataframe()
    print("[cli] Backtest summary:")
    print(df)

    out_path = Path(args.output)
    df.to_csv(out_path, index=False, encoding="utf-8-sig")
    print(f"[cli] Result saved to: {out_path.resolve()}")


if __name__ == "__main__":
    main()

6. cli/run_portfolio_live_replay.py — 命令行仿真实盘入口
# cli/run_portfolio_live_replay.py
from __future__ import annotations

"""
组合仿真实盘（tick 回放）命令行入口。

用法示例（在项目根目录）：
    python -m cli.run_portfolio_live_replay

当前默认使用：
    - PortfolioConfig: portfolio.example_config.EXAMPLE_PORTFOLIO_CONFIG
    - Broker: QmtBroker(dry_run=True, initial_cash=1_000_000)
"""

import argparse
from pathlib import Path

from portfolio.example_config import EXAMPLE_PORTFOLIO_CONFIG
from portfolio.runner import PortfolioLiveReplayRunner


def main() -> None:
    parser = argparse.ArgumentParser(description="Run portfolio live replay.")
    parser.add_argument(
        "--output-dir",
        type=str,
        default="portfolio_live_orders",
        help="每个实例订单日志导出目录（CSV）",
    )
    args = parser.parse_args()

    cfg = EXAMPLE_PORTFOLIO_CONFIG
    print(f"[cli] Start portfolio live replay (dry_run): {cfg.name}")

    runner = PortfolioLiveReplayRunner(cfg)

    try:
        all_orders = runner.run_replay()
    except FileNotFoundError as e:
        print("[cli] Tick data missing, 请先完成 tick 数据下载。")
        print("Error:", e)
        return

    out_dir = Path(args.output_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    for key, df in all_orders.items():
        fname = key.replace(":", "_") + ".csv"
        out_path = out_dir / fname
        df.to_csv(out_path, index=False, encoding="utf-8-sig")
        print(f"[cli] Orders for {key} saved to {out_path.resolve()}")


if __name__ == "__main__":
    main()