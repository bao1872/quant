1. 回测引擎空头仓位的现金 & 权益计算有 bug（需要优先修）

文件：backtest/engine.py 中 BacktestContext

现状问题

现在的逻辑大致是：

开多：

self.cash -= price * qty
self.position_side = "long"
self.position_price = price


平多（在 side == "sell" and position_side == "long" 分支）：

pnl = (price - self.position_price) * self.position_qty
self.cash += self.position_qty * self.position_price + pnl


开空：

proceeds = price * qty
self.cash += proceeds
self.position_side = "short"
self.position_price = price


平空（在 side == "buy" and position_side == "short" 分支）：

pnl = (self.position_price - price) * self.position_qty
self.cash += self.position_qty * self.position_price + pnl


这样会有两个问题：

多头平仓时现金多加了一次开仓成本
正确做法是「开仓时减成本、平仓时只加平仓成交额」，不需要再加开仓价 * 数量。

空头的现金和权益都算错了

开空时已经把 proceeds = P0 * Q 加到 cash 里。

平空时再 cash += P0 * Q + pnl，等于又把开仓收入加了一遍。

_update_equity 里对空头是：

if self.position_side == "long":
    pos_value = current_price * qty
else:
    pos_value = self.position_price * qty


对空头来说，这个 pos_value 应该是 负的当前市值，而不是开仓价 * 数量。

我在本地简单模拟了一下（开空 10 元 100 股，9 元平仓），当前实现的结果是：

初始 cash = 100000

开空后 cash = 101000

平空后 cash = 102100（多出来 2000），但记录的 pnl 只有 100 —— 这就是典型的算错。

建议修改方案

把逻辑改成现金流 + 市值一致的版本：

class BacktestContext:
    ...

    def send_order(self, ts_code: str, side: str, price: float, qty: int, reason: str, meta: Dict[str, Any]) -> None:
        price = float(price)
        qty = int(qty)
        dt = meta.get("dt", pd.Timestamp.now())

        if side == "buy":
            if self.position_side is None:
                # 开多
                cost = price * qty
                if cost > self.cash:
                    return
                self.cash -= cost
                self.position_side = "long"
                self.position_qty = qty
                self.position_price = price
                self.position_open_dt = pd.Timestamp(dt)

            elif self.position_side == "short":
                # 平空
                if qty != self.position_qty:
                    # 简化：当前版本只支持一次性全平
                    return
                pnl = (self.position_price - price) * self.position_qty
                # 平空实际上是用 cash 去回购股票
                self.cash -= price * self.position_qty
                self.trades.append(
                    TradeRecord(
                        ts_code=ts_code,
                        side="cover",
                        entry_dt=self.position_open_dt or pd.Timestamp(dt),
                        exit_dt=pd.Timestamp(dt),
                        entry_price=self.position_price,
                        exit_price=price,
                        pnl=pnl,
                        reason=reason,
                    )
                )
                self.position_side = None
                self.position_qty = 0
                self.position_price = 0.0
                self.position_open_dt = None

        elif side == "sell":
            if self.position_side is None:
                # 开空
                proceeds = price * qty
                self.cash += proceeds
                self.position_side = "short"
                self.position_qty = qty
                self.position_price = price
                self.position_open_dt = pd.Timestamp(dt)

            elif self.position_side == "long":
                # 平多
                if qty != self.position_qty:
                    # 简化：当前版本只支持一次性全平
                    return
                pnl = (price - self.position_price) * self.position_qty
                # 平多收回平仓价 * 数量
                self.cash += price * self.position_qty
                self.trades.append(
                    TradeRecord(
                        ts_code=ts_code,
                        side="sell",
                        entry_dt=self.position_open_dt or pd.Timestamp(dt),
                        exit_dt=pd.Timestamp(dt),
                        entry_price=self.position_price,
                        exit_price=price,
                        pnl=pnl,
                        reason=reason,
                    )
                )
                self.position_side = None
                self.position_qty = 0
                self.position_price = 0.0
                self.position_open_dt = None

        self._update_equity(current_price=price)

    def _update_equity(self, current_price: float) -> None:
        pos_value = 0.0
        if self.position_side is not None and self.position_qty > 0:
            if self.position_side == "long":
                pos_value = current_price * self.position_qty
            elif self.position_side == "short":
                # 空头仓位的市值是负的
                pos_value = -current_price * self.position_qty
        self.equity = self.cash + pos_value


这样：

多头：

开仓：cash -= P0 * Q；

平仓：cash += Pc * Q；

最终 cash = 初始 + (Pc - P0) * Q。

空头：

开仓：cash += P0 * Q；

平仓：cash -= Pc * Q；

最终 cash = 初始 + (P0 - Pc) * Q。

_update_equity 对任意时刻都满足：equity = initial_cash + 已实现PnL + 未实现PnL。

2. 多日回测时，策略内部 _position 与回测上下文仓位状态不一致

文件：strategy/abu_level_strategy.py，方法 _on_new_day & on_tick
文件：backtest/engine.py，TickBacktester.run

现状

AbuKeyLevelStrategy._on_new_day 中：

def _on_new_day(self, trade_date: date) -> None:
    self._current_trade_date = trade_date
    self._tick_buffer = []
    self._position = None  # 简化：日内策略，每天收盘不留 overnight
    ...


也就是说策略内部状态认为“新的一天不留仓”。

但 TickBacktester.run 的循环是：

ctx = BacktestContext(...)
strat = AbuKeyLevelStrategy(...)
for d in trade_dates:
    df_ticks = tick_store.load_ticks(...)
    for row in df_ticks.to_dict("records"):
        strat.on_tick(row, ctx)


回测上下文 ctx 是跨多天复用的；

每天结束时并没有做「强制平仓」；

如果某天最后一个 tick 时还持仓，第二天 _on_new_day 会把 self._position 清掉，但 ctx 里的真实仓位还在。

造成的问题

多日回测时，会出现：

策略内部认为已经「日内清仓」；

回测上下文仍然有持仓，权益在按旧仓位标记市值；

之后再产生信号，很可能会产生与实盘不一致的仓位行为。

建议改法（两种方案，选一种）

方案 A：策略明确支持「隔夜持仓」，就不要在 _on_new_day 里清 _position

把 _on_new_day 中的 self._position = None 去掉；

让平仓动作完全由 _handle_existing_position 的止损/止盈逻辑完成；

这样：strategy 层和 context 层的状态始终是一致的。

方案 B：保持「日内策略」的设定，在回测引擎里增加 EOD 强制平仓

例如在 TickBacktester.run 中每天循环末尾加一个「收盘时刻」回调：

class TickBacktester:
    ...
    def run(...):
        ctx = BacktestContext(initial_cash=self.initial_cash)
        strat = AbuKeyLevelStrategy(...)

        for d in trade_dates:
            df_ticks = self.tick_store.load_ticks(...)
            if df_ticks.empty:
                continue

            last_price = None
            last_dt = None

            for row in df_ticks.to_dict("records"):
                tick_dt = row["datetime"]
                price = float(row["price"])
                last_price = price
                last_dt = tick_dt
                strat.on_tick(row, ctx)

            # 日内结束，强制平仓（若还持仓）
            if strat._position is not None and last_price is not None:
                pos = strat._position
                side = "sell" if pos.side == "long" else "buy"
                ctx.send_order(
                    ts_code=self.ts_code,
                    side=side,
                    price=last_price,
                    qty=pos.qty,
                    reason="eod_flat",
                    meta={"dt": last_dt, "force_flat": True},
                )
                strat._position = None


不论你选 A 还是 B，一定要保证策略内部 _position 和回测/实盘上下文里的仓位状态是一致的。
如果你觉得以后会有持仓跨日的策略，推荐用方案 A。

3. strategy/__main__.py 引用的 _REGISTRY 未定义

文件：strategy/__main__.py

现在是：

from .registry import _REGISTRY

if __name__ == "__main__":
    print("strategy package self-test")
    print("Available strategies:", list(_REGISTRY.keys()))


但 strategy/registry.py 中并没有 _REGISTRY 这个变量，只定义了 StrategyRegistry 类。
这在你执行 python -m strategy 或被其他工具调用时会直接 ImportError。

建议修正

两种简单做法：

做法 1：在 registry.py 里加一个全局注册表

# registry.py 顶部或中部
_REGISTRY = {
    "abu_key_level": (AbuKeyLevelStrategy, AbuPriceLevelProvider, AbuMicrostructureAnalyzer),
}

class StrategyRegistry:
    def __init__(self) -> None:
        self._factories = _REGISTRY
    ...


这样 __main__.py 可以继续用 _REGISTRY。

做法 2：不暴露 _REGISTRY，改用工厂类

把 __main__.py 改成：

from .registry import StrategyRegistry

if __name__ == "__main__":
    print("strategy package self-test")
    reg = StrategyRegistry()
    print("Available strategies:", list(reg._factories.keys()))


对项目功能没影响，只是自测脚本的小问题，但最好修掉，避免未来有人依赖这个入口。

4. Tick 存储依赖 parquet 引擎，需要在你的环境里安装

文件：data/tick_store.py

你用的是：

df.to_parquet(file_path)
pd.read_parquet(file_path)


在我这边会报：

Missing optional dependency 'pyarrow' or 'fastparquet'

在你的开发/生产环境里，只要确保安装了其一即可：

pip install pyarrow
# 或者
pip install fastparquet


不算代码 bug，但这是一个部署时必须注意的依赖。

5. DB 模型目前是「假 ORM」，打开真实 Postgres 会出问题

文件：db/models.py

现在的模型类似：

class TickFileIndex:
    def __init__(..., file_path, record_cnt, time_start, time_end, checksum):
        self.ts_code = ts_code
        ...


但你在 tick_store.save_ticks 里是用：

from db.connection import get_session
from db.models import TickFileIndex

with get_session() as session:
    ...
    idx = TickFileIndex(...)
    session.merge(idx)


而 db/connection.py 的 get_session() 只有在 USE_REAL_DB=1 时才创建 SQLAlchemy 的 Session；当前这套 TickFileIndex 类 并不是映射到任何 ORM 表上的，在真 DB 场景会报错。

当前阶段的情况

你现在测试阶段都是 USE_REAL_DB=0，走的是 DummySession，所以不会报错；

但一旦你把 USE_REAL_DB 打开，TickFileIndex 相关写入一定是不能用的。

建议

把「真 ORM 模型」作为后续一个阶段独立出来，比如：

用 SQLAlchemy Declarative Base 实现真正的 StockBasic, StockDaily, TickFileIndex, PriceLevelsDaily；

保持接口不变（TickStore 仍然是 save_ticks / load_ticks），只内部替换。

这一点不用现在改，但你迁移到真实 Postgres 的时候，要记得这个坑。

6. 微观结构 & 关键位策略本身的一致性 & 性能

这一块整体逻辑是对的，和我们之前约定的思路基本匹配：

AbuPriceStructureExtractor + AbuPriceLevelProvider 负责盘后计算关键位，并落库（或 Dummy 环境下跳过）。

AbuMicrostructureAnalyzer 只关注「某个关键位附近的一小段 tick 窗」：

价格离关键位的相对距离 dist_pct；

总成交量 total_vol；

B/S 比例；

穿透程度 penetration_pct；

然后输出一个 MicroSignal（方向 + score + meta）。

AbuKeyLevelStrategy 每个 tick 的流程：

检查是否新的一天，加载当日关键位；

维护 tick buffer（时间窗）；

根据 _position 决定是先处理已有仓位还是寻找新机会；

在价格接近关键位时调用 micro_analyzer.analyze_near_level(...)；

score 合格 → 计算仓位大小 → ctx.send_order(...)。

一致性方面

从现在的代码来看，回测和实盘的逻辑如果共用 AbuKeyLevelStrategy，是天然一致的：

关键位来源：统一通过 PriceLevelProvider；

微观结构分析：统一用 AbuMicrostructureAnalyzer；

下单入口：统一通过 ctx.send_order(...)。

只要你将来实盘那边的 ctx 实现（比如 QmtContext）遵守同一个接口（get_position / cash / equity / send_order），逻辑路径就能完全复用。

性能方面

现在的实现有一个「可以以后优化」的点：

def _get_tick_window(self, dt: datetime) -> pd.DataFrame:
    window_seconds = int(self.config["micro_window_seconds"])
    start = dt - timedelta(seconds=window_seconds)
    rows = [t for t in self._tick_buffer if start <= t["datetime"] <= dt]
    return pd.DataFrame(rows)


每个 tick 都从 _tick_buffer 全表扫描，构造一个新的 DataFrame，O(N)；

在高频 tick（单日几万、十几万）时会有性能压力。

优化方向（可以后面一个阶段再做）：

把 _tick_buffer 换成一个按时间升序的 deque：

新 tick append；

每次只从左边 pop 掉超出时间窗的部分；

然后 _get_tick_window 可以直接用 list(self._tick_buffer) 建表，复杂度接近 O(window_size)，而不是 O(total_ticks)。

这不影响正确性，只是性能和内存优化。

总结：当前阶段是否“能用”？以及建议优先修什么

综合结论：

阶段 0–3 的整体架构和模块划分是合理的，和你最初的“可复用框架 + 可以替换策略核心”的目标是对齐的；

在 Dummy DB + 本地测试 tick 的前提下，大部分代码可以正常跑通；

但要让「回测结果可信」并且为后面真实实盘准备，有几处必须调整。

我建议的优先级：

立刻修：BacktestContext 空头 & 平多/空 的现金和权益计算
这是会直接把回测 PnL 算错的关键 bug。

尽快决定：策略是允许隔夜，还是强制日内平仓

允许隔夜 → 删掉 _on_new_day 里清 _position 的那一行；

强制日内 → 在 TickBacktester 里加「收盘强制平仓」逻辑。
两者选一个就好，关键是保证策略状态和上下文仓位一致。

顺手修：strategy/__main__.py 的 _REGISTRY 引用
小问题，但修掉会干净很多。

记在 TODO 里：ORM 真模型 + parquet 依赖

ORM：等你准备好切真实 Postgres 再统一上；

parquet：保证你的运行环境安装了 pyarrow 或 fastparquet。