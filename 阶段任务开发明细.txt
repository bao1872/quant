阶段 4 目标（按我们之前的规划）：

实盘交易接入：用 qmtmini 做下单，但通过一个统一的 Context 接口，和回测完全复用同一套策略逻辑。

实盘/仿真运行器：把 tick 数据源 + 策略 + 实盘上下文串起来。

可视化前端（Streamlit）：查看 K 线 + 阿布关键位、简单回测/交易结果展示。

下面这些是「阶段 4 新增/重要文件」：

live/qmt_client.py — 封装 qmtmini 的交易客户端（默认 dry-run，方便你先联调）

live/context.py — 实盘上下文（LiveContext），接口与回测 BacktestContext 对齐

live/runner.py — 实盘/仿真运行器（用 TickStore 回放 + LiveContext + 策略）

live/__init__.py

ui/streamlit_app.py — Streamlit 可视化：K 线 + 阿布关键位

你可以按文件名直接放进当前仓库对应目录。

1. live/qmt_client.py — qmtmini 封装（支持 dry-run）
# live/qmt_client.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional
import threading
import time
import uuid


@dataclass
class QmtOrder:
    order_id: str
    ts_code: str
    side: str      # "buy" / "sell"
    price: float
    qty: int
    status: str    # "new" / "filled" / "rejected"
    remark: str


class QmtClient:
    """
    qmtmini 封装。

    当前默认实现为 dry-run（只记录订单，不真正发给券商），你可以在标记 TODO
    的地方替换为你自己的 qmtmini 接口调用。

    预期能力：
        - connect / disconnect
        - get_account_info: 返回现金、总资产等
        - get_positions: 返回持仓列表
        - place_order: 下单（市价/限价），返回 order_id
    """

    def __init__(
        self,
        account_id: Optional[str] = None,
        dry_run: bool = True,
        extra_config: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.account_id = account_id or "default"
        self.dry_run = dry_run
        self.extra_config = extra_config or {}
        self._connected = False
        self._lock = threading.Lock()
        self._orders: List[QmtOrder] = []

        # dry-run 下的模拟资金与持仓
        self._cash = float(self.extra_config.get("initial_cash", 1_000_000.0))
        self._equity = self._cash
        self._positions: Dict[str, Dict[str, Any]] = {}  # ts_code -> {qty, cost}

    # -------------------- 连接 / 断开 --------------------

    def connect(self) -> None:
        """
        建立与 qmtmini 的连接。

        TODO: 在这里替换为你的真实 qmtmini 登录逻辑。
        """
        if self._connected:
            return
        # 真实环境：调用 qmtmini 的登录/连接接口
        # 例如：self._api = miniqmt.Xxx(...); self._api.connect()
        self._connected = True
        print(f"[QmtClient] connected (dry_run={self.dry_run})")

    def disconnect(self) -> None:
        """
        断开连接。
        """
        if not self._connected:
            return
        # TODO: 调用 qmtmini 的断开接口
        self._connected = False
        print("[QmtClient] disconnected")

    # -------------------- 账户 / 持仓 --------------------

    def get_account_info(self) -> Dict[str, Any]:
        """
        返回账户资金信息。
        真正接入时，用 qmtmini 的资金查询结果替换这里的实现。
        """
        if not self._connected:
            raise RuntimeError("QmtClient not connected")

        if not self.dry_run:
            # TODO: 调用 qmtmini 查询资金
            # 返回格式尽量与当前保持一致：{"cash": ..., "equity": ...}
            pass

        return {
            "account_id": self.account_id,
            "cash": self._cash,
            "equity": self._equity,
        }

    def get_positions(self) -> List[Dict[str, Any]]:
        """
        返回当前持仓列表。
        """
        if not self._connected:
            raise RuntimeError("QmtClient not connected")

        if not self.dry_run:
            # TODO: 调用 qmtmini 查询持仓
            pass

        res: List[Dict[str, Any]] = []
        for ts_code, pos in self._positions.items():
            res.append(
                {
                    "ts_code": ts_code,
                    "qty": pos["qty"],
                    "cost": pos["cost"],
                }
            )
        return res

    # -------------------- 下单 --------------------

    def place_order(
        self,
        ts_code: str,
        side: str,
        price: float,
        qty: int,
        order_type: str = "limit",
        remark: str = "",
    ) -> str:
        """
        下单接口。

        side: "buy" / "sell"
        order_type: "limit" / "market"（当前实现统一按成交价处理）
        """
        if not self._connected:
            raise RuntimeError("QmtClient not connected")

        price = float(price)
        qty = int(qty)
        order_id = uuid.uuid4().hex

        with self._lock:
            order = QmtOrder(
                order_id=order_id,
                ts_code=ts_code,
                side=side,
                price=price,
                qty=qty,
                status="new",
                remark=remark,
            )
            self._orders.append(order)

            if self.dry_run:
                # 在 dry-run 下，我们直接假设以提交价格全部成交。
                self._simulate_fill(order)
            else:
                # TODO: 在这里调用 qmtmini 的实单下单接口，
                #       并根据回报更新 self._orders / self._positions / self._cash / self._equity
                self._simulate_fill(order)  # 在你接真实接口前，保留这个方便调试

        print(f"[QmtClient] order placed: {order}")
        return order_id

    # -------------------- dry-run 填充逻辑 --------------------

    def _simulate_fill(self, order: QmtOrder) -> None:
        """
        在 dry-run 或未接真接口时，用简单规则模拟成交并更新资金与持仓。
        """
        if order.status == "filled":
            return

        ts_code = order.ts_code
        price = order.price
        qty = order.qty

        # 买入时，减少现金、增加持仓
        if order.side == "buy":
            cost = price * qty
            if cost > self._cash:
                order.status = "rejected"
                order.remark += " | insufficient cash"
                return

            self._cash -= cost
            pos = self._positions.get(ts_code, {"qty": 0, "cost": 0.0})
            total_qty = pos["qty"] + qty
            if total_qty > 0:
                pos["cost"] = (pos["cost"] * pos["qty"] + cost) / total_qty
            pos["qty"] = total_qty
            self._positions[ts_code] = pos
            order.status = "filled"

        elif order.side == "sell":
            pos = self._positions.get(ts_code, {"qty": 0, "cost": 0.0})
            if qty > pos["qty"]:
                order.status = "rejected"
                order.remark += " | insufficient position"
                return
            proceeds = price * qty
            self._cash += proceeds
            pos["qty"] -= qty
            if pos["qty"] <= 0:
                self._positions.pop(ts_code, None)
            else:
                self._positions[ts_code] = pos
            order.status = "filled"

        self._equity = self._cash  # 简化：不计未实现盈亏

    # -------------------- 工具 --------------------

    def get_orders(self) -> List[QmtOrder]:
        with self._lock:
            return list(self._orders)


if __name__ == "__main__":
    # 简单自测
    client = QmtClient(dry_run=True, extra_config={"initial_cash": 100_000})
    client.connect()
    print("Account:", client.get_account_info())

    oid1 = client.place_order("000001.SZ", "buy", 10.0, 1000, remark="test_buy")
    oid2 = client.place_order("000001.SZ", "sell", 10.5, 500, remark="test_sell")

    print("Orders:", client.get_orders())
    print("Positions:", client.get_positions())
    print("Account after trades:", client.get_account_info())

    client.disconnect()

2. live/context.py — 实盘上下文（对齐策略所需接口）
# live/context.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

import pandas as pd

from .qmt_client import QmtClient, QmtOrder


@dataclass
class LiveTradeRecord:
    ts_code: str
    dt: datetime
    side: str          # "buy" / "sell"
    price: float
    qty: int
    reason: str
    meta: Dict[str, Any]
    order_id: str
    status: str


class LiveContext:
    """
    实盘上下文（用于给 AbuKeyLevelStrategy 使用），接口与 BacktestContext 尽量对齐：

    - 属性：
        - cash: float
        - equity: float
    - 方法：
        - send_order(ts_code, side, price, qty, reason, meta)

    注意：
        - 真实持仓 & 资金以券商为准，这里只做「轻量缓存」与日志记录；
        - 策略风控（单笔风险、最大仓位等）在策略内完成，
          LiveContext 只做最基本的 sanity check。
    """

    def __init__(
        self,
        client: QmtClient,
        ts_code: Optional[str] = None,
        max_slippage_pct: float = 0.002,
    ) -> None:
        self.client = client
        self.ts_code = ts_code
        self.max_slippage_pct = float(max_slippage_pct)

        self.cash: float = 0.0
        self.equity: float = 0.0
        self.trades: List[LiveTradeRecord] = []

        self.refresh_account()

    # --------------- 账户信息 ---------------

    def refresh_account(self) -> None:
        info = self.client.get_account_info()
        self.cash = float(info.get("cash", 0.0))
        self.equity = float(info.get("equity", self.cash))

    # --------------- 策略调用的核心接口 ---------------

    def send_order(
        self,
        ts_code: str,
        side: str,
        price: float,
        qty: int,
        reason: str,
        meta: Dict[str, Any],
    ) -> None:
        """
        策略下单接口。

        side: "buy" / "sell"
        """
        # 若策略绑定了 ts_code，则强制一致
        if self.ts_code is not None and ts_code != self.ts_code:
            # 多标的实盘时，你可以改为 raise 或路由到其它 LiveContext
            print(f"[LiveContext] ignore order for {ts_code}, context bound to {self.ts_code}")
            return

        qty = int(qty)
        price = float(price)
        dt = meta.get("dt")
        if dt is None:
            dt = datetime.now()

        remark = f"{reason}"
        order_id = self.client.place_order(
            ts_code=ts_code,
            side=side,
            price=price,
            qty=qty,
            order_type="limit",
            remark=remark,
        )

        # 刷新账户信息
        self.refresh_account()

        # 从 client 中找到刚刚的订单记录
        status = "unknown"
        for od in self.client.get_orders():
            if od.order_id == order_id:
                status = od.status
                break

        rec = LiveTradeRecord(
            ts_code=ts_code,
            dt=dt,
            side=side,
            price=price,
            qty=qty,
            reason=reason,
            meta=meta,
            order_id=order_id,
            status=status,
        )
        self.trades.append(rec)

        print(f"[LiveContext] order sent: {rec}")

    # --------------- 工具方法 ---------------

    def trades_to_dataframe(self) -> pd.DataFrame:
        if not self.trades:
            return pd.DataFrame(
                columns=[
                    "ts_code",
                    "dt",
                    "side",
                    "price",
                    "qty",
                    "reason",
                    "order_id",
                    "status",
                ]
            )
        rows = []
        for t in self.trades:
            rows.append(
                {
                    "ts_code": t.ts_code,
                    "dt": t.dt,
                    "side": t.side,
                    "price": t.price,
                    "qty": t.qty,
                    "reason": t.reason,
                    "order_id": t.order_id,
                    "status": t.status,
                }
            )
        return pd.DataFrame(rows)


if __name__ == "__main__":
    # 自测：用 dry-run 的 QmtClient 测试一笔买卖
    client = QmtClient(dry_run=True, extra_config={"initial_cash": 100_000})
    client.connect()

    ctx = LiveContext(client=client, ts_code="000001.SZ")
    print("Initial account:", ctx.cash, ctx.equity)

    ctx.send_order(
        ts_code="000001.SZ",
        side="buy",
        price=10.0,
        qty=1000,
        reason="test_entry",
        meta={},
    )

    ctx.send_order(
        ts_code="000001.SZ",
        side="sell",
        price=10.5,
        qty=1000,
        reason="test_exit",
        meta={},
    )

    print("Account after:", ctx.cash, ctx.equity)
    print(ctx.trades_to_dataframe())

    client.disconnect()

3. live/runner.py — 实盘/仿真运行器（Tick 回放 + 策略 + LiveContext）

这里我提供一个**“仿真实盘”**实现：
使用 TickStore 中已有的 tick 数据，按时间顺序回放，并通过 LiveContext 触发 QmtClient 下单。
你把 dry_run=False 改成实盘版本、并把数据源改成实时 pytdx，即可变成真正的实盘 loop。

# live/runner.py
from __future__ import annotations

from datetime import date, datetime
from typing import Any, Dict, List, Optional
import time

import pandas as pd

from data.tick_store import TickStore
from factors import AbuPriceLevelProvider
from microstructure import AbuMicrostructureAnalyzer
from strategy.abu_level_strategy import AbuKeyLevelStrategy
from .qmt_client import QmtClient
from .context import LiveContext


class LiveRunner:
    """
    实盘 / 仿真运行器：

    当前版本：使用 TickStore 回放某日某票的 tick 数据，
    让 AbuKeyLevelStrategy + LiveContext 跑一遍完整流程。

    将来接入实盘：
        - 把 tick 源改成 pytdx 实时推送/轮询
        - QmtClient 设置 dry_run=False，填入你的真实 qmtmini 调用
    """

    def __init__(
        self,
        ts_code: str,
        dry_run: bool = True,
        qmt_config: Optional[Dict[str, Any]] = None,
        strategy_config: Optional[Dict[str, Any]] = None,
    ) -> None:
        self.ts_code = ts_code
        self.dry_run = dry_run
        self.qmt_config = qmt_config or {}
        self.strategy_config = strategy_config or {}

        self.tick_store = TickStore()
        self.price_level_provider = AbuPriceLevelProvider()
        self.micro_analyzer = AbuMicrostructureAnalyzer()

        self.client = QmtClient(
            dry_run=self.dry_run,
            extra_config=self.qmt_config,
        )

        self.ctx = LiveContext(
            client=self.client,
            ts_code=self.ts_code,
        )

        self.strategy = AbuKeyLevelStrategy(
            ts_code=self.ts_code,
            price_level_provider=self.price_level_provider,
            micro_analyzer=self.micro_analyzer,
            config=self.strategy_config,
        )

    def run_replay(
        self,
        trade_date: date,
        speed: float = 0.0,
    ) -> None:
        """
        用 TickStore 的数据回放某一交易日的 tick。

        speed:
            - 0.0: 尽快跑完（仅用于调试）
            - >0: 每个 tick 之间 sleep 的秒数（模拟实时节奏）
        """
        self.client.connect()

        df = self.tick_store.load_ticks(self.ts_code, trade_date)
        if df is None or df.empty:
            print(f"[LiveRunner] no tick data for {self.ts_code} {trade_date}")
            self.client.disconnect()
            return

        df = df.sort_values("datetime").reset_index(drop=True)

        print(
            f"[LiveRunner] start replay {self.ts_code} {trade_date}, "
            f"ticks={len(df)}, dry_run={self.dry_run}"
        )

        for _, row in df.iterrows():
            tick = self._row_to_tick(row)
            # 把当前 tick 时间放进 meta，方便 LiveContext 记录
            tick_meta = {"dt": tick["datetime"]}
            # AbuKeyLevelStrategy 不用 meta 参数，所以我们只能在 ctx.send_order 里补上
            # 这里的处理是：策略 on_tick 正常跑，ctx 在 send_order 时自己填 dt=now 或 meta["dt"]

            self.strategy.on_tick(tick, self.ctx)

            if speed > 0:
                time.sleep(speed)

        print(f"[LiveRunner] replay finished. Trades:")
        print(self.ctx.trades_to_dataframe())

        self.client.disconnect()

    def _row_to_tick(self, row: pd.Series) -> Dict[str, Any]:
        dt = row["datetime"]
        if not isinstance(dt, datetime):
            dt = pd.to_datetime(dt).to_pydatetime()

        return {
            "ts_code": self.ts_code,
            "datetime": dt,
            "price": float(row["price"]),
            "volume": int(row.get("volume", 0)),
            "side": row.get("side", "N"),
        }


if __name__ == "__main__":
    # 自测：如果 TickStore 中有某票某日的 tick，可以跑一遍回放（dry_run，不会真下单）
    from datetime import timedelta

    ts = "000001.SZ"
    today = date.today()
    d = today - timedelta(days=1)

    runner = LiveRunner(
        ts_code=ts,
        dry_run=True,
        qmt_config={"initial_cash": 100_000},
        strategy_config={"min_signal_score": 60.0},
    )
    runner.run_replay(trade_date=d, speed=0.0)

4. live/__init__.py
# live/__init__.py
"""
实盘相关模块入口。
"""

from .qmt_client import QmtClient, QmtOrder
from .context import LiveContext, LiveTradeRecord
from .runner import LiveRunner

__all__ = [
    "QmtClient",
    "QmtOrder",
    "LiveContext",
    "LiveTradeRecord",
    "LiveRunner",
]


if __name__ == "__main__":
    print("live package self-test, exports:", __all__)

5. ui/streamlit_app.py — Streamlit 可视化（K 线 + 关键位）

一个简洁的可视化应用：

左侧选股票、日期区间；

从 stock_daily 读 K 线，从 price_levels_daily 读阿布关键位；

用 Plotly 画出 K 线 + 关键位水平线；

底部表格展示关键位信息。

需要依赖：streamlit、plotly。
你可以用 pip install streamlit plotly 安装。

# ui/streamlit_app.py
from __future__ import annotations

from datetime import date
from typing import List

import pandas as pd
import plotly.graph_objects as go
import streamlit as st
from sqlalchemy import text

from db.connection import get_session
from data.repository import get_all_stock_basics
from factors import AbuPriceLevelProvider


def load_daily_bars(ts_code: str, start: date, end: date) -> pd.DataFrame:
    with get_session() as session:
        sql = text(
            """
            select trade_date, open, high, low, close, volume, amount
            from stock_daily
            where ts_code = :ts
              and trade_date between :start and :end
            order by trade_date
            """
        )
        df = pd.read_sql(
            sql,
            session.get_bind(),
            params={"ts": ts_code, "start": start, "end": end},
        )
    if df.empty:
        return df
    df["trade_date"] = pd.to_datetime(df["trade_date"])
    return df


def load_price_levels(ts_code: str, trade_date: date) -> pd.DataFrame:
    plp = AbuPriceLevelProvider()
    levels = plp.get_levels(ts_code, trade_date)
    if not levels:
        return pd.DataFrame(
            columns=[
                "ts_code",
                "trade_date",
                "level_price",
                "level_type",
                "direction",
                "strength",
                "source_flags",
            ]
        )
    rows = []
    for lv in levels:
        rows.append(
            {
                "ts_code": lv.ts_code,
                "trade_date": lv.trade_date,
                "level_price": lv.level_price,
                "level_type": lv.level_type,
                "direction": lv.direction,
                "strength": lv.strength,
                "source_flags": ",".join(lv.source_flags or []),
            }
        )
    df = pd.DataFrame(rows)
    df["trade_date"] = pd.to_datetime(df["trade_date"])
    return df


def main() -> None:
    st.set_page_config(
        page_title="A股阿布关键位策略可视化",
        layout="wide",
    )

    st.title("A股阿布价格理论关键位可视化")

    # ---------- 左侧选择股票 & 日期 ----------

    basics = get_all_stock_basics()
    if not basics:
        st.error("stock_basic 为空，请先跑数据更新任务。")
        return

    ts_codes: List[str] = [b.ts_code for b in basics]
    names: List[str] = [f"{b.ts_code} {b.name}" for b in basics]
    code_to_name = dict(zip(ts_codes, names))

    ts = st.sidebar.selectbox("选择股票", options=ts_codes, format_func=lambda x: code_to_name.get(x, x))

    today = date.today()
    start = st.sidebar.date_input("开始日期", value=today.replace(year=today.year - 1))
    end = st.sidebar.date_input("结束日期", value=today)

    level_date = st.sidebar.date_input("关键位日期（通常选最近一个交易日）", value=end)

    st.sidebar.write("---")
    st.sidebar.write("提示：")
    st.sidebar.write("1. 先用数据更新任务拉取日线和关键位。")
    st.sidebar.write("2. 实盘/回测逻辑由后端模块完成，这里只负责可视化。")

    # ---------- 加载数据 ----------

    with st.spinner("加载日线数据..."):
        df_ohlc = load_daily_bars(ts, start, end)

    if df_ohlc.empty:
        st.warning("选定区间内无日线数据。")
        return

    with st.spinner("加载关键位数据..."):
        df_levels = load_price_levels(ts, level_date)

    # ---------- 绘制 K 线 + 关键位 ----------

    fig = go.Figure()

    fig.add_trace(
        go.Candlestick(
            x=df_ohlc["trade_date"],
            open=df_ohlc["open"],
            high=df_ohlc["high"],
            low=df_ohlc["low"],
            close=df_ohlc["close"],
            name="K线",
        )
    )

    if not df_levels.empty:
        # 按方向分别画
        for direction, color in [("support", "green"), ("resistance", "red"), ("neutral", "blue")]:
            sub = df_levels[df_levels["direction"] == direction]
            for _, row in sub.iterrows():
                fig.add_hline(
                    y=row["level_price"],
                    line=dict(color=color, width=1, dash="dot"),
                    annotation_text=f"{direction} | {row['level_type']} | {row['strength']}",
                    annotation_position="right",
                )

    fig.update_layout(
        xaxis_title="日期",
        yaxis_title="价格",
        xaxis_rangeslider_visible=False,
        height=600,
    )

    st.plotly_chart(fig, use_container_width=True)

    # ---------- 关键位表格 ----------

    st.subheader(f"{ts} {level_date} 关键价格列表")
    if df_levels.empty:
        st.info("该日尚未计算关键位。请先跑 AbuPriceLevelProvider.precompute(trade_date)。")
    else:
        st.dataframe(
            df_levels.sort_values("level_price"),
            use_container_width=True,
        )


if __name__ == "__main__":
    # 直接 python ui/streamlit_app.py 时给出提示
    print(
        "请用命令运行 Streamlit 应用：\n\n"
        "    streamlit run ui/streamlit_app.py\n"
    )
    # 也可以直接调用 main() 在命令行调试数据加载逻辑
    # main()

怎么把阶段 4 跑起来（简要）

安装新依赖（如果还没装）：

pip install streamlit plotly pyarrow


仿真“实盘跑策略”（不下真单）：

python -m live.runner


（确保 TickStore 下有对应 ts_code + trade_date 的 tick 文件）

查看 K 线 + 关键位：

streamlit run ui/streamlit_app.py