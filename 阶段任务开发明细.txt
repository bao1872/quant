ä¸€ã€å¼€å‘è¯´æ˜ï¼ˆç®€åŒ–ç‰ˆï¼‰
1. ç›®æ ‡

å¯¹ã€ŒæŸä¸€åªè‚¡ç¥¨ + æŸä¸€å‘¨æœŸã€çš„ä¸€æ®µå†å² K çº¿ï¼Œè‡ªåŠ¨ç»™å‡ºä¸€ä¸ªæ¨èçš„ swing_lengthï¼š

ä½ è‡ªå·±è®¾ä¸€ä¸ªå€™é€‰åˆ—è¡¨ï¼š
L_list = [3, 4, 5, 6, 8, 10, 12]

å¯¹æ¯ä¸ª Lï¼š

è·‘ä¸€æ¬¡ compute_ict_structures(..., swing_length=L)ï¼›

æŠŠè¯¥ L ä¸‹æ‰€æœ‰ OB çš„å®½åº¦ç®—å‡ºæ¥ï¼š

rel_width
=
âˆ£
ğ‘‡
ğ‘œ
ğ‘
âˆ’
ğµ
ğ‘œ
ğ‘¡
ğ‘¡
ğ‘œ
ğ‘š
âˆ£
(
ğ‘‡
ğ‘œ
ğ‘
+
ğµ
ğ‘œ
ğ‘¡
ğ‘¡
ğ‘œ
ğ‘š
)
/
2
rel_width=
(Top+Bottom)/2
âˆ£Topâˆ’Bottomâˆ£
	â€‹


æ±‚è¿™å †å®½åº¦é‡Œçš„ æœ€å°å€¼ï¼šmin_width(L)ã€‚

é€‰æ‹©è§„åˆ™ï¼š

ä»å°åˆ°å¤§æ‰« Lï¼Œ
æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ»¡è¶³ min_width(L) â‰¥ target_width çš„ Lï¼ˆä¾‹å¦‚ target_width=0.01 è¡¨ç¤º 1%ï¼‰ï¼›

å¦‚æœä¸€ä¸ªéƒ½æ²¡æœ‰æ»¡è¶³ï¼ˆè¯´æ˜æ‰€æœ‰ L çš„æœ€çª„ OB éƒ½ <1%ï¼‰ï¼Œ
å°±é€‰é‚£ä¸ª min_width(L) æœ€å¤§çš„ Lï¼ˆæœ€æ¥è¿‘ 1% çš„ï¼‰ã€‚

ç‰¹ä¾‹ï¼š

æŸä¸ª L ä¸‹ä¸€ä¸ª OB éƒ½æ²¡æœ‰ â†’ è·³è¿‡ï¼›

æ‰€æœ‰ L éƒ½æ²¡æœ‰ OB â†’ è¿”å›é»˜è®¤å€¼ default_Lï¼ˆä¾‹å¦‚ 5ï¼‰ã€‚

2. æ–‡ä»¶ & è°ƒç”¨æ–¹å¼

æ–°å»ºæ¨¡å—ï¼ˆæˆ–ç›´æ¥æ”¹ä½ ç°åœ¨çš„ï¼‰ï¼š

analysis/ob_swing_tuner.py

ä½¿ç”¨æ­¥éª¤ï¼š

from analysis.ob_swing_tuner import (
    evaluate_swing_lengths,
    auto_choose_swing_length_min_based,
)

bars_15m = load_15m_bars(ts_code)   # ä½ è‡ªå·±çš„åŠ è½½å‡½æ•°

L_list = [3, 4, 5, 6, 8, 10, 12]

stats_map = evaluate_swing_lengths(bars_15m, L_list)
best_L = auto_choose_swing_length_min_based(
    stats_map,
    target_width=0.01,   # å¸Œæœ›æœ€çª„çš„ OB ä¹Ÿä¸ä½äº 1%
    default_L=5,         # ä¸‡ä¸€å•¥éƒ½è¯„ä¸å‡ºæ¥å°±ç”¨ 5
)

print("æ¨è swing_length:", best_L)
for L, s in sorted(stats_map.items()):
    print(
        f"L={L:2d}, n_ob={s.n_ob:3d}, "
        f"min={s.min_width*100:.2f}%, "
        f"median={s.median_width*100:.2f}%, "
        f"mean={s.mean_width*100:.2f}%"
    )


å†æŠŠ best_L ä½œä¸ºï¼š

è¿™ä¸ªæ ‡çš„ + å‘¨æœŸçš„ é»˜è®¤ swing_lengthï¼›

Streamlit ä¾§è¾¹æ çš„é»˜è®¤å€¼ï¼ˆä½ ä»ç„¶å¯ä»¥æ‰‹åŠ¨æ»‘åŠ¨è°ƒæ•´ï¼‰ã€‚

äºŒã€å®Œæ•´æ ¸å¿ƒä»£ç ï¼ˆæ—  quantileã€æ—  min_ob é™åˆ¶ï¼‰

ç›´æ¥æ”¾ä¸€ä¸ªå®Œæ•´çš„ ob_swing_tuner.pyï¼Œä½ å¯ä»¥æŒ‰éœ€è°ƒæ•´è·¯å¾„/å¯¼å…¥åï¼š

# analysis/ob_swing_tuner.py

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Sequence, Optional, Tuple

import numpy as np
import pandas as pd

from factors.ict_smc import ICTConfig, compute_ict_structures


@dataclass
class SwingStats:
    """
    å•ä¸ª swing_length ä¸‹ï¼ŒOB å®½åº¦åˆ†å¸ƒçš„ç»Ÿè®¡ç»“æœã€‚
    rel_width = |Top - Bottom| / mid_price
    mid_price = (Top + Bottom) / 2
    """
    swing_length: int
    n_ob: int
    min_width: float
    median_width: float
    mean_width: float


def _compute_ob_width_stats(
    bars: pd.DataFrame,
    swing_length: int,
    ob_flag_col: str = "ict_ob_flag",
    ob_top_col: str = "ict_ob_top",
    ob_bottom_col: str = "ict_ob_bottom",
) -> Optional[SwingStats]:
    """
    å¯¹ç»™å®šçš„ swing_lengthï¼Œè®¡ç®— OB å®½åº¦çš„ç»Ÿè®¡é‡ï¼ˆåŸºäºâ€œæœ€å°å®½åº¦â€æ€è·¯ï¼‰ã€‚

    å‚æ•°
    ----
    bars : pd.DataFrame
        è‡³å°‘åŒ…å« open/high/low/close åˆ—ï¼ŒæŒ‰æ—¶é—´å‡åºã€‚
    swing_length : int
        ä¼ ç»™ ICT çš„æ‘†åŠ¨é•¿åº¦ã€‚
    ob_flag_col / ob_top_col / ob_bottom_col :
        compute_ict_structures è¾“å‡ºçš„ OB ç›¸å…³åˆ—åã€‚

    è¿”å›
    ----
    SwingStats æˆ– None
    - è‹¥è¯¥ swing_length ä¸‹å®Œå…¨æ²¡æœ‰ OBï¼Œåˆ™è¿”å› Noneã€‚
    """

    cfg = ICTConfig(swing_length=swing_length)
    df_ict = compute_ict_structures(bars, cfg)

    # æ²¡æœ‰ OB æ ‡è®°åˆ—ï¼Œç›´æ¥æ”¾å¼ƒè¿™ä¸ª L
    if ob_flag_col not in df_ict.columns:
        return None

    mask_ob = df_ict[ob_flag_col].fillna(0) != 0
    if not mask_ob.any():
        # è¿™ä¸ª L ä¸‹ä¸€ä¸ª OB éƒ½æ²¡æœ‰
        return None

    ob_rows = df_ict.loc[mask_ob, [ob_top_col, ob_bottom_col]].dropna()
    if ob_rows.empty:
        return None

    # å®½åº¦å’Œä¸­ä»·
    width = (ob_rows[ob_top_col] - ob_rows[ob_bottom_col]).abs()
    mid_price = ((ob_rows[ob_top_col] + ob_rows[ob_bottom_col]) / 2.0).abs()

    # é˜²æ­¢é™¤ä»¥ 0
    mid_price = mid_price.replace(0, np.nan)
    rel_width = (width / mid_price).dropna()  # ç›¸å¯¹å®½åº¦ï¼Œä¾‹å¦‚ 0.01 = 1%

    if rel_width.empty:
        return None

    n_ob = len(rel_width)
    min_w = float(rel_width.min())
    median_w = float(rel_width.median())
    mean_w = float(rel_width.mean())

    return SwingStats(
        swing_length=swing_length,
        n_ob=n_ob,
        min_width=min_w,
        median_width=median_w,
        mean_width=mean_w,
    )


def evaluate_swing_lengths(
    bars: pd.DataFrame,
    swing_lengths: Sequence[int],
) -> Dict[int, SwingStats]:
    """
    å¯¹ä¸€ç»„å€™é€‰ swing_length é€ä¸ªè¯„ä¼° OB å®½åº¦åˆ†å¸ƒã€‚

    å‚æ•°
    ----
    bars : pd.DataFrame
        æŸæ ‡çš„æŸå‘¨æœŸçš„ä¸€æ®µå†å² K çº¿ã€‚
    swing_lengths : åºåˆ—[int]
        å€™é€‰çš„æ‘†åŠ¨é•¿åº¦åˆ—è¡¨ï¼Œä¾‹å¦‚ [3,4,5,6,8,10,12]ã€‚

    è¿”å›
    ----
    ä¸€ä¸ª dict: {swing_length: SwingStats}
    åªåŒ…å«â€œè‡³å°‘æœ‰ 1 ä¸ª OBâ€çš„ Lã€‚
    """
    stats_map: Dict[int, SwingStats] = {}

    for L in swing_lengths:
        stats = _compute_ob_width_stats(bars, L)
        if stats is not None:
            stats_map[L] = stats

    return stats_map


def auto_choose_swing_length_min_based(
    stats_map: Dict[int, SwingStats],
    target_width: float = 0.01,
    default_L: Optional[int] = None,
) -> Optional[int]:
    """
    åŸºäºâ€œæœ€å° OB å®½åº¦â€çš„è‡ªåŠ¨é€‰å–æ‘†åŠ¨é•¿åº¦ï¼ˆå®Œå…¨ç¬¦åˆä½ æçš„ min æ€è·¯ï¼‰ï¼š

    é€»è¾‘ï¼š
    1) è‹¥ stats_map ä¸ºç©ºï¼š
       - è‹¥ç»™äº† default_Lï¼Œåˆ™è¿”å› default_Lï¼›
       - å¦åˆ™è¿”å› Noneã€‚
    2) å¦åˆ™ï¼š
       - å°† (L, stats) æŒ‰ L ä»å°åˆ°å¤§æ’åºã€‚
       - Step 1: ä»å°åˆ°å¤§æ‰¾ç¬¬ä¸€ä¸ªæ»¡è¶³
                 stats.min_width >= target_width
                 çš„ Lï¼Œè¿”å›å®ƒã€‚
       - Step 2: è‹¥æ²¡æœ‰ä»»ä½• L æ»¡è¶³ Step 1ï¼š
                 åœ¨æ‰€æœ‰ L ä¸­ï¼Œé€‰æ‹© min_width æœ€å¤§çš„é‚£ä¸ª L è¿”å›ã€‚
                 ï¼ˆè¡¨ç¤ºâ€œè™½ç„¶éƒ½ä¸åˆ° 1%ï¼Œä½†è¿™ä¸ª L çš„æœ€çª„ OB å·²ç»æ˜¯ç›¸å¯¹æœ€å¤§äº†â€ï¼‰
    """

    if not stats_map:
        return default_L

    # æŒ‰ L å‡åºæ’åˆ—
    items: list[Tuple[int, SwingStats]] = sorted(stats_map.items(), key=lambda x: x[0])

    # Step 1: ä»å°åˆ°å¤§æ‰¾ç¬¬ä¸€ä¸ª min_width >= target_width çš„ L
    for L, s in items:
        if s.min_width >= target_width:
            return L

    # Step 2: è‹¥æ²¡æœ‰ä»»ä½• L åˆ°è¾¾ target_widthï¼Œé€‰ min_width æœ€å¤§çš„ L
    best_L = None
    best_min = -1.0

    for L, s in items:
        if s.min_width > best_min:
            best_min = s.min_width
            best_L = L

    return best_L