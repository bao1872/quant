一、你要实现的四件事

StockBasic：全市场 A 股股票池（主板/中小板/创业板/科创板，剔除 ST）

K 线历史：至少最近 2 年的日线 OHLC 数据

Tick：当前版本支持“每日盘后抓取最近 N 笔 tick，写入 TickStore”

APScheduler：每天盘后自动跑一次增量更新（股票池 + 日线 + tick + 因子）

下面所有代码都按你现在的项目结构来写：

quant/
  config.py
  data/
    base_source.py
    pytdx_source.py
    repository.py
    updater.py
    jobs.py          # 会替换成新版本
    basic_universe.py  # 新增
  cli/
    backfill_history.py  # 新增
  scheduler.py       # 新增

二、修改 1：放开股票池上限（一次性跑全 A 股）

文件：config.py

你现在是：

def _parse_optional_int(env_name: str, default: str) -> int | None:
    v = os.getenv(env_name, default)
    v = v.strip() if isinstance(v, str) else v
    if v == "":
        return None
    return int(v)

STOCK_POOL_LIMIT: int | None = _parse_optional_int("STOCK_POOL_LIMIT", "20")
TICK_COUNT_LIMIT: int = int(os.getenv("TICK_COUNT_LIMIT", "1000"))


改成：

def _parse_optional_int(env_name: str, default: str) -> int | None:
    v = os.getenv(env_name, default)
    v = v.strip() if isinstance(v, str) else v
    if v == "":
        return None
    return int(v)

# 默认不限制股票池（全市场）；调试时可以在环境变量里设置 STOCK_POOL_LIMIT=100 之类的
STOCK_POOL_LIMIT: int | None = _parse_optional_int("STOCK_POOL_LIMIT", "")

# 每只股票抓多少条 tick（pytdx 限制一般是 2000 左右）
TICK_COUNT_LIMIT: int = int(os.getenv("TICK_COUNT_LIMIT", "1000"))


这样 _get_all_stock_codes() 默认就会返回 所有 stock_basic 里的股票，而不再只取 20 只。

三、修改 2：新增全 A 股股票池构建模块

文件（新增）：data/basic_universe.py

这个模块用 pytdx 的 get_security_list 拉深/沪所有证券列表，然后：

通过 代码前缀 判断是不是 A 股（主板/中小板/创业板/科创板）

用 名字里是否包含 “ST”/“退” 过滤 ST & 退市股 
GitHub
+1

生成 ts_code = code.market（如 000001.SZ）

写入 stock_basic 表（默认先 TRUNCATE 再插入）

# data/basic_universe.py
"""
A 股股票池管理与 stock_basic 表回填脚本。

功能：
- 从 pytdx 行情服务器获取沪深全部证券列表；
- 过滤出 A 股（主板 / 中小板 / 创业板 / 科创板）且剔除 ST、退市；
- 生成 ts_code（如 000001.SZ），写入 Postgres 中的 stock_basic 表；
- 提供 ensure_stock_basic_a_share() 在定时任务中每日调用，保证股票池最新。

使用前准备：
- 已在 config.DATABASE_URL 中配置好 Postgres 连接；
- 已安装 pytdx：  pip install pytdx ;
- 推荐在环境变量中设置 USE_REAL_DB=1 ，确保真正写库。
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List

import pandas as pd
from pytdx.hq import TdxHq_API
from sqlalchemy import text

from config import MARKET_SZ, MARKET_SH
from db.connection import get_engine

A_SHARE_PREFIX_SZ = ("000", "001", "002", "003", "300")
A_SHARE_PREFIX_SH = ("600", "601", "603", "605", "688", "689")


@dataclass
class AShareBasic:
    ts_code: str
    code: str
    name: str
    market: str   # "SZ" / "SH"
    board: str    # "SZ_MAIN" / "SZ_SMEB" / "SZ_CHINEXT" / "SH_MAIN" / "SH_STAR"


def _connect_td_api() -> TdxHq_API:
    api = TdxHq_API()
    # 可以换成你稳定的 pytdx 服务器
    hosts = [
        ("119.147.164.60", 7709),
        ("180.153.18.171", 7709),
        ("114.80.149.19", 7709),
        ("115.238.90.165", 7709),
        ("123.125.108.23", 7709),
        ("218.108.98.244", 7709),
    ]
    for ip, port in hosts:
        try:
            if api.connect(ip, port):
                print(f"[basic_universe] Connected pytdx {ip}:{port}")
                return api
        except Exception as e:  # noqa: BLE001
            print(f"[basic_universe] connect {ip}:{port} failed: {e}")
    raise RuntimeError("basic_universe: 无法连接任一 pytdx 服务器，请检查网络或更换节点。")


def _fetch_market_list(api: TdxHq_API, market: int, market_name: str) -> pd.DataFrame:
    """
    拉取某市场全部证券列表，并附加 market 列（'SZ' / 'SH'）。
    """
    from math import ceil

    total = api.get_security_count(market)
    if not total or total <= 0:
        return pd.DataFrame()
    all_chunks: List[pd.DataFrame] = []
    for i in range(ceil(total / 1000)):
        start = i * 1000
        rows = api.get_security_list(market=market, start=start)
        if not rows:
            break
        df = pd.DataFrame(rows)
        df["market"] = market_name
        all_chunks.append(df)
    if not all_chunks:
        return pd.DataFrame()
    df_all = pd.concat(all_chunks, ignore_index=True)
    return df_all


def _classify_board(code: str, market_name: str) -> str:
    if market_name == "SZ":
        if code.startswith(("000", "001", "003")):
            return "SZ_MAIN"
        if code.startswith("002"):
            return "SZ_SMEB"
        if code.startswith("300"):
            return "SZ_CHINEXT"
        return ""
    else:  # SH
        if code.startswith(("600", "601", "603", "605")):
            return "SH_MAIN"
        if code.startswith(("688", "689")):
            return "SH_STAR"
        return ""


def load_a_share_universe() -> pd.DataFrame:
    """
    返回过滤后的 A 股股票列表 DataFrame，字段：
    - ts_code
    - code
    - name
    - market
    - board
    """
    api = _connect_td_api()
    try:
        df_sz = _fetch_market_list(api, MARKET_SZ, "SZ")
        df_sh = _fetch_market_list(api, MARKET_SH, "SH")
    finally:
        api.disconnect()

    if df_sz.empty and df_sh.empty:
        raise RuntimeError("basic_universe: 从 pytdx 未取到任何证券列表。")

    df_all = pd.concat([df_sz, df_sh], ignore_index=True)

    # 只保留必要字段
    # 常见字段：code, name, volunit, decimal_point, pre_close
    cols = [c for c in ["code", "name", "market"] if c in df_all.columns]
    df = df_all[cols].copy()

    # 剔除缺失 code 的行
    df = df[df["code"].astype(str).str.len() > 0].reset_index(drop=True)

    # 分类板块 + 过滤 A 股
    df["board"] = df.apply(
        lambda r: _classify_board(str(r["code"]), str(r["market"])),
        axis=1,
    )
    df = df[df["board"] != ""].copy()

    # 过滤 ST / 退市
    name_series = df["name"].astype(str)
    mask_st = (
        name_series.str.contains("ST", case=False, na=False)
        | name_series.str.contains("退", na=False)
    )
    df = df[~mask_st].copy()

    # 生成 ts_code
    df["code"] = df["code"].astype(str).str.zfill(6)
    df["ts_code"] = df["code"] + "." + df["market"].astype(str)

    df = df[["ts_code", "code", "name", "market", "board"]].drop_duplicates(
        subset=["ts_code"]
    )
    df = df.sort_values(["market", "code"]).reset_index(drop=True)

    print(f"[basic_universe] A 股非 ST 股票数量: {len(df)}")
    return df


def save_stock_basic(df: pd.DataFrame) -> int:
    """
    将 DataFrame 写入 stock_basic 表。

    简化策略：
    - 如果已存在 stock_basic：先 TRUNCATE，再插入；
    - 如果不存在：自动创建（仅包含 df 中的字段）。

    如你已有自定义字段，可以在建表时先手工加上默认值 / 允许 NULL。
    """
    eng = get_engine()
    if eng is None:
        print("[basic_universe] 当前未启用真实数据库 (USE_REAL_DB != 1)，仅返回 DataFrame。")
        return 0

    with eng.begin() as conn:
        # 尝试截断原表（如果不存在会失败，我们忽略异常）
        try:
            conn.execute(text("TRUNCATE TABLE stock_basic"))
            print("[basic_universe] 已清空 stock_basic 表。")
        except Exception as e:  # noqa: BLE001
            print(f"[basic_universe] TRUNCATE stock_basic 失败，可能是首次创建表：{e}")

    # 追加写入
    df.to_sql("stock_basic", eng, if_exists="append", index=False)
    print(f"[basic_universe] 已写入 stock_basic 行数: {len(df)}")
    return len(df)


def ensure_stock_basic_a_share() -> int:
    """
    对外入口：
    - 从 pytdx 拉取最新 A 股列表；
    - 写入 / 覆盖 stock_basic。
    """
    df = load_a_share_universe()
    return save_stock_basic(df)


if __name__ == "__main__":
    # 手动执行：python -m data.basic_universe
    cnt = ensure_stock_basic_a_share()
    print(f"[basic_universe] DONE, count={cnt}")

四、修改 3：调整 jobs.py，让日线一次拿够 2 年，并支持不限股票数抓 tick

文件（替换原文件）：data/jobs.py

# data/jobs.py
"""
定时任务入口（供 APScheduler 或手工脚本调用）。

包含三个主要 Job：
- job_update_ohlc: 盘前 / 盘后更新日线 & 分钟线
- job_collect_ticks_once: 抓取当日 tick（当前为“最近 N 笔”）
- job_finalize_ticks_and_levels: 收盘后（或盘前）计算关键价位等因子
"""

from __future__ import annotations

from datetime import date as _date

from .updater import (
    update_daily_bars,
    update_minute_bars,
    collect_intraday_ticks,
)
from .repository import get_all_stock_basics
from factors import AbuPriceLevelProvider


def job_update_ohlc(trade_date: _date) -> None:
    """
    更新 OHLC（open / high / low / close）相关的 K 线数据。

    当前实现：
    - 日线：对股票池中全部 ts_code，拉取最近 600 条日线；
      * 首次运行时，数据库为空，会写入最近 ~2 年的日线数据；
      * 此后每天运行时，只会对“数据库中最后 trade_date 之后”的部分做增量写入；
    - 分钟线：默认关闭，如需 1 分钟 K 线，可解除注释。
    """
    print(f"[job_update_ohlc] trade_date={trade_date}")

    # 日线：最近 600 条（约 2 年）
    update_daily_bars(trade_date=trade_date, count=600)

    # 如果需要分钟线，可打开下面一行（注意数据量 & 访问频率）：
    # update_minute_bars(trade_date=trade_date, freq="1m", count=240)


def job_collect_ticks_once(trade_date: _date, limit: int | None = 20) -> None:
    """
    抓取当日 tick 数据并写入 TickStore（parquet + tick_file_index）。

    参数：
    - trade_date: 交易日期
    - limit: 限制股票数量；None 或 <=0 表示对股票池中全部标的抓取。

    说明：
    - 当前 collect_intraday_ticks 使用 pytdx 网络接口，只能获取最近 N 笔成交；
      无法直接一次性拿到完整的“当日全量 tick”，因此严格意义上的
      “最近两年 tick 全量历史”仍需配合本地通达信数据文件等方式回填。
    """
    basics = get_all_stock_basics()
    ts_codes = [s.ts_code for s in basics]
    if limit is not None and limit > 0:
        ts_codes = ts_codes[:limit]
        print(f"[job_collect_ticks_once] limit={limit} -> 实际抓取 {len(ts_codes)} 只股票")
    else:
        print(f"[job_collect_ticks_once] 不限制股票数量，抓取 {len(ts_codes)} 只股票")

    collect_intraday_ticks(trade_date=trade_date, ts_codes=ts_codes, count=1000)


def job_finalize_ticks_and_levels(trade_date: _date) -> None:
    """
    基于 tick / 日线等数据重新计算关键价位（供因子使用）。
    """
    print(f"[job_finalize_ticks_and_levels] trade_date={trade_date}")
    provider = AbuPriceLevelProvider()
    provider.precompute(trade_date)


if __name__ == "__main__":
    from datetime import date as date_cls

    today = date_cls.today()
    print("[jobs] self test -> job_update_ohlc")
    job_update_ohlc(today)
    print("[jobs] self test -> job_finalize_ticks_and_levels")
    job_finalize_ticks_and_levels(today)


说明：

update_daily_bars(trade_date, count=600) 会对每只股票取最近 600 条日线（你在 pytdx_source 里已经写好按时间升序 + upsert）。

limit=None 时，job_collect_ticks_once 会对股票池中所有股票抓 tick。
建议一开始调试时用 limit=100 + 比较小的 STOCK_POOL_LIMIT，确认速度和磁盘占用再放开。

五、修改 4：新增 CLI 一键历史回填脚本

文件（新增）：cli/backfill_history.py

这个脚本就是你手动执行一次，用来初始化历史数据。

# cli/backfill_history.py
"""
一次性历史数据回填入口。

执行步骤：
1）根据 pytdx 行情服务器自动生成 A 股（主板 / 中小板 / 创业板 / 科创板，剔除 ST）
    股票池，并写入 stock_basic；
2）回填最近 600 条日线数据（约 2 年历史）到 stock_daily；
3）可选：抓取当日 tick、计算关键价位等。

用法：
- 在项目根目录执行：  python -m cli.backfill_history
- 或者： python cli/backfill_history.py
"""

from __future__ import annotations

from datetime import date

from data.basic_universe import ensure_stock_basic_a_share
from data.jobs import job_update_ohlc, job_collect_ticks_once, job_finalize_ticks_and_levels


def main() -> None:
    today = date.today()
    print(f"[backfill_history] 回填基准日期 trade_date={today}")

    print("[backfill_history] 1) 回填 A 股股票池到 stock_basic ...")
    ensure_stock_basic_a_share()

    print("[backfill_history] 2) 回填最近 ~2 年日线数据到 stock_daily ...")
    job_update_ohlc(today)

    print("[backfill_history] 3) 抓取当日 tick（当前仅最近 N 笔） ...")
    # 如不需要 tick，可以注释掉下面一行
    job_collect_ticks_once(today, limit=None)

    print("[backfill_history] 4) 计算价位因子 ...")
    job_finalize_ticks_and_levels(today)

    print("[backfill_history] 历史数据回填完成。")


if __name__ == "__main__":
    main()

六、修改 5：新增 APScheduler 定时任务入口

文件（新增）：项目根目录 scheduler.py

这个文件用 APScheduler 的 BlockingScheduler，每个交易日盘后 15:10 自动跑：

更新股票池

更新最近 600 条日线

抓取当日 tick

计算因子

# scheduler.py
"""
使用 APScheduler 管理量化项目的定时任务。

主要任务：
- 每个交易日盘后（默认为 15:10，收盘后预留几分钟）：
    1）更新 A 股股票池（主板/中小板/创业板/科创板，剔除 ST）；
    2）回填最近若干日的日线数据（默认 600 个交易日 ≈ 2 年）；
    3）可选：分钟线；
    4）抓取当日 tick（当前通过 pytdx 网络接口，只能拿到最近 N 笔，非完整两年历史）；
    5）计算关键价位等因子。

使用方式：
- 安装依赖： pip install apscheduler pytz
- 在项目根目录执行：  python scheduler.py
- 部署时可以用 systemd / supervisor 等将其作为常驻进程。
"""

from __future__ import annotations

from datetime import date, datetime

import pytz
from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.triggers.cron import CronTrigger

from config import Settings
from data.basic_universe import ensure_stock_basic_a_share
from data.jobs import job_update_ohlc, job_collect_ticks_once, job_finalize_ticks_and_levels

TZ_CN = pytz.timezone("Asia/Shanghai")


def is_trading_day(d: date) -> bool:
    """
    简单判断交易日：周一~周五视为交易日。
    更精细的节假日过滤可以后续接入交易所日历或 tushare 等。
    """
    return d.weekday() < 5  # 0=Monday, 6=Sunday


def run_post_close_jobs(trade_date: date | None = None) -> None:
    """
    盘后主任务：
    - 更新股票池
    - 更新日线（最近 600 条）
    - 抓取当日 tick
    - 计算价位因子
    """
    if trade_date is None:
        trade_date = date.today()

    if not is_trading_day(trade_date):
        print(f"[scheduler] {trade_date} 非交易日，跳过盘后任务。")
        return

    print(f"[scheduler] ====== 开始盘后任务 trade_date={trade_date} ======")

    # 1) 更新 A 股股票池
    ensure_stock_basic_a_share()

    # 2) 更新日线 / 分钟线
    #   - update_daily_bars 内部会根据数据库中已有的最后交易日做增量控制；
    #   - count 设为 600，首次运行即可拿到最近 ~2 年的日线数据。
    print("[scheduler] 更新日线 / 分钟线 ...")
    job_update_ohlc(trade_date)

    # 如果后续需要分钟线，可以在 data.jobs.job_update_ohlc 中打开 update_minute_bars 调用；
    # 这里不单独再调一次，避免重复。

    # 3) 抓取当日 tick（当前实现为“最近 N 笔”，由 config.TICK_COUNT_LIMIT 控制）
    print("[scheduler] 抓取当日 tick ...")
    # limit=None 表示对股票池中全部标的抓取
    job_collect_ticks_once(trade_date, limit=None)

    # 4) 计算价位等因子
    print("[scheduler] 重新计算价位因子 ...")
    job_finalize_ticks_and_levels(trade_date)

    print(f"[scheduler] ====== 盘后任务完成 trade_date={trade_date} ======")


def main() -> None:
    """
    启动 APScheduler，注册定时任务。
    """
    scheduler = BlockingScheduler(timezone=TZ_CN)

    # 每个交易日 15:10 触发盘后任务（若想调整时间，可以改 hour/minute）
    scheduler.add_job(
        func=lambda: run_post_close_jobs(),
        trigger=CronTrigger(hour=15, minute=10),
        id="post_close_job",
        name="A 股盘后数据更新",
        replace_existing=True,
    )

    print("[scheduler] APScheduler 已启动，等待定时任务触发 ...")
    try:
        scheduler.start()
    except (KeyboardInterrupt, SystemExit):
        print("[scheduler] 收到退出信号，正在停止 ...")


if __name__ == "__main__":
    main()