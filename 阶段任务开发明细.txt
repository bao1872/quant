一、要做的事一共 3 步

在日频特征里计算 20 日平均成交额列（amount_20d_avg）

在训练样本构建阶段加一条过滤条件：amount_20d_avg ≥ 1e8

在每日选股 / 算仓位时，同样先用这个条件过滤

下面分别说。

二、Step 1：计算 20 日平均成交额 amount_20d_avg
方案 A：在数据库里用 SQL 窗口函数计算（推荐）

假设你日频表里已经有：

表：stock_tick_daily_features 或 stock_kline / stock_bollinger_data

字段：ts_code, trade_date, amount_sum（或 amount）

可以在建表或建视图的时候加一列：

ALTER TABLE stock_tick_daily_features
    ADD COLUMN amount_20d_avg NUMERIC;

UPDATE stock_tick_daily_features AS t
SET amount_20d_avg = sub.amount_20d_avg
FROM (
    SELECT
        ts_code,
        trade_date,
        AVG(amount_sum) OVER (
            PARTITION BY ts_code
            ORDER BY trade_date
            ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
        ) AS amount_20d_avg
    FROM stock_tick_daily_features
) AS sub
WHERE t.ts_code = sub.ts_code
  AND t.trade_date = sub.trade_date;


说明：

这就是严格的“过去 20 个交易日（含当日）平均成交额”；

如果你更谨慎，可以改成用到 t-1 为止（排除当日）：ROWS BETWEEN 20 PRECEDING AND 1 PRECEDING；

用的是窗口函数，不会用到未来数据。

之后，ETL 定时任务跑完 tick 日聚合后，可以顺带跑这个 UPDATE，或者做成视图。

方案 B：在加载特征的 Python 里滚动计算

如果你倾向在 Python 里做（比如已经读了一个大 df），伪代码如下：

def add_amount_20d_avg(df: pd.DataFrame) -> pd.DataFrame:
    # df 至少包含: ts_code, trade_date, amount_sum
    df = df.sort_values(["ts_code", "trade_date"])
    df["amount_20d_avg"] = (
        df.groupby("ts_code")["amount_sum"]
          .transform(lambda s: s.rolling(20, min_periods=10).mean())
    )
    return df


然后在你 load 日频特征的地方，加上这一行即可。

三、Step 2：训练样本构建时加流动性过滤

你现在 Stock Pool Ml Samples 是从 stock_bollinger_data + tick 特征合并出来的，对吧。

在你构建样本/载入样本时，加一条过滤：

# 假设 df_pool 里已经 merge 进了 amount_20d_avg
LIQ_THRES = 1e8  # 1 亿

before = len(df_pool)
df_pool = df_pool[df_pool["amount_20d_avg"] >= LIQ_THRES].copy()
after = len(df_pool)

print(f"[build_pool] liquidity filter: {before} -> {after} rows "
      f"(amount_20d_avg >= {LIQ_THRES:.0f})")


要注意两点：

只用历史数据算的 20 日平均（前面已经保证了）；

训练阶段和实盘阶段用完全一致的过滤逻辑，避免 train-test mismatch。

如果你是在 SQL 里先筛选股票池再写入 stock_pool_ml_samples，也可以直接写：

WHERE amount_20d_avg >= 100000000

四、Step 3：实盘选股 / 仓位控制时加这个条件

当你每天做“选股 + 算仓位”时，在那一步的 universe 过滤里，加一条简单规则：

def filter_universe_liquidity(df_today, thres=1e8):
    """
    df_today: 当日候选股票的截面数据
              必须包含 amount_20d_avg（可以是 t 或 t-1）
    """
    mask = df_today["amount_20d_avg"] >= thres
    df_filt = df_today[mask].copy()
    print(
        f"[universe] liquidity filter: {len(df_today)} -> {len(df_filt)} "
        f"(amount_20d_avg >= {thres:.0f})"
    )
    return df_filt


然后在你的选股逻辑里：

df_today = load_today_features(...)
df_today = filter_universe_liquidity(df_today, thres=1e8)

# 再按 pred_ret_10d 排序，选择 top N，算权重等