一、策略层：在 run_ict_mtf_backtest 里记录调试明细

目标：每根 K 线一行，记录：

日线趋势：trend_state

位置判断：在不在 OB？（执行周期 / 日线）

K 线信号：bull_rev / bear_rev

是否满足入场前提：can_open_long / can_open_short

是否实际开仓/平仓：opened_long / opened_short / closed_pos

当前持仓：position_side / position_qty

当前止损/止盈：stop_price / target_price

当前资金：equity

1.1 扩展回测结果 dataclass

在 strategy/ict_mtf_lab.py 里，把 IctBacktestResult 改一下，多一个 debug：

@dataclass
class IctBacktestResult:
    trades: List[IctTrade]
    equity: pd.Series         # 执行周期上的资金曲线
    config: IctMtfConfig
    debug: pd.DataFrame       # 每根bar的调试信息

1.2 在回测函数里准备 debug_rows 容器

在 run_ict_mtf_backtest 内，主循环前加：

    trades: List[IctTrade] = []
    equity_values: List[float] = []
    debug_rows: List[dict] = []   # 新增：存调试明细

1.3 循环里增加调试变量 + 记录

在 for i in range(len(merged)): 这个循环里，建议做如下改动：

(1) 每次迭代先初始化“事件标志”

放在循环最开头、处理平仓逻辑之前：

        opened_long = False
        opened_short = False
        closed_pos = False

        # 取当前 OHLC
        o = float(row["open"])
        c = float(row["close"])

        # 取上一根 K 线用于反转判断
        if i > 0:
            prev_row = merged.iloc[i - 1]
            prev_o = float(prev_row["open"])
            prev_c = float(prev_row["close"])
            bull_rev = _is_bullish_reversal(prev_o, prev_c, o, c)
            bear_rev = _is_bearish_reversal(prev_o, prev_c, o, c)
        else:
            bull_rev = False
            bear_rev = False


这里用的是我们之前约好的“反转阳线/反转阴线”，不再用 CHOCH。

(2) 平仓时，把 closed_pos 标成 True

在你平仓那一段的逻辑里（有 exit_px is not None: 的地方），平仓成功后加一行：

                if exit_px is not None:
                    closed_pos = True   # 这根bar发生了平仓事件
                    ...


其他 cash / pnl 逻辑保持你现在修好的版本即可。

(3) 入场逻辑里打 can_open_* & opened_*

在“无持仓 → 尝试开新仓”那段，
原来大概是：

        if position_side is None:
            if trend == TrendState.LONG:
                # 计算 in_ob ...
                if in_ob and bull_rev:
                    # 算止损、仓位、R:R...
                    if 通过RR过滤:
                        position_side = "long"
                        position_qty = ...
                        ...


我们加两个变量：

        can_open_long = False
        can_open_short = False


然后在多头分支里这样写（示意核心改动）：

        if position_side is None:
            if trend == TrendState.LONG:
                in_ob_long = False

                # 执行周期 OB 优先
                if ob_flag > 0 and "ict_ob_top" in row and "ict_ob_bottom" in row:
                    ob_bottom = float(row["ict_ob_bottom"])
                    ob_top = float(row["ict_ob_top"])
                    in_ob_long = _price_in_range(price, ob_bottom, ob_top, config.ob_tolerance_pct)
                else:
                    ob_bottom = float(row.get("ob_long_bottom", np.nan))
                    ob_top = float(row.get("ob_long_top", np.nan))
                    in_ob_long = _price_in_range(price, ob_bottom, ob_top, config.ob_tolerance_pct)

                # 先只判断“前提是否满足”
                if in_ob_long and bull_rev:
                    can_open_long = True

                    # === 下面才是原来的“真正开仓”逻辑 ===
                    # 止损
                    if np.isnan(ob_bottom) or ob_bottom <= 0 or ob_bottom >= price:
                        stop = price * (1.0 - 0.005)
                    else:
                        stop = ob_bottom

                    risk_per_share = price - stop
                    if risk_per_share > 0:
                        risk_budget = equity * config.risk_per_trade_pct
                        max_position_value = equity * config.max_position_pct
                        qty = int(risk_budget / risk_per_share)
                        qty = (qty // config.lot_size) * config.lot_size
                        if qty > 0:
                            position_value = qty * price
                            if position_value > max_position_value:
                                qty = int(max_position_value // price)
                                qty = (qty // config.lot_size) * config.lot_size

                        if qty > 0:
                            target = price + config.min_rr * risk_per_share
                            entry_px = price * (1.0 + config.slippage_pct)
                            # 最小 R:R 过滤
                            if (target - entry_px) / (entry_px - stop) >= config.min_rr:
                                position_side = "long"
                                position_qty = int(qty)
                                entry_price = float(entry_px)
                                stop_price = float(stop)
                                target_price = float(target)
                                cash -= entry_price * position_qty
                                opened_long = True   # 真正开多仓


空头分支同样模式（这里写核心差异）：

            elif trend == TrendState.SHORT:
                in_ob_short = False
                if ob_flag < 0 and "ict_ob_top" in row and "ict_ob_bottom" in row:
                    ob_top = float(row["ict_ob_top"])
                    ob_bottom = float(row["ict_ob_bottom"])
                    in_ob_short = _price_in_range(price, ob_bottom, ob_top, config.ob_tolerance_pct)
                else:
                    ob_top = float(row.get("ob_short_top", np.nan))
                    ob_bottom = float(row.get("ob_short_bottom", np.nan))
                    in_ob_short = _price_in_range(price, ob_bottom, ob_top, config.ob_tolerance_pct)

                if in_ob_short and bear_rev:
                    can_open_short = True

                    # === 原有开空逻辑 ===
                    if np.isnan(ob_top) or ob_top <= 0 or ob_top <= price:
                        stop = price * (1.0 + 0.005)
                    else:
                        stop = ob_top

                    risk_per_share = stop - price
                    ...
                            target = price - config.min_rr * risk_per_share
                            entry_px = price * (1.0 - config.slippage_pct)
                            if (entry_px - target) / (stop - entry_px) >= config.min_rr:
                                position_side = "short"
                                position_qty = int(qty)
                                entry_price = float(entry_px)
                                stop_price = float(stop)
                                target_price = float(target)
                                cash += entry_price * position_qty
                                opened_short = True


关键是：

can_open_long/short = 条件判断通过（位置 + 反转K线）

opened_long/short = 实际开仓成功（包括R:R和仓位计算）

(4) 每根 K 线末尾 append debug_row

在循环末尾（已经算出当前 equity 之后），加：

        # 持仓状态字符串
        pos_state = position_side if position_side is not None else "flat"

        debug_rows.append({
            "datetime": dt,
            "close": price,
            "trend_state": str(trend),          # 方便在表里看
            "in_exec_ob_flag": ob_flag,         # 当前bar的OB标记
            "bull_rev": bull_rev,
            "bear_rev": bear_rev,
            "can_open_long": can_open_long,
            "can_open_short": can_open_short,
            "opened_long": opened_long,
            "opened_short": opened_short,
            "closed_pos": closed_pos,
            "position_side": pos_state,
            "position_qty": int(position_qty),
            "stop_price": float(stop_price) if stop_price else np.nan,
            "target_price": float(target_price) if target_price else np.nan,
            "equity": float(equity),
        })

1.4 回测结束后构造 debug DataFrame

在函数 return 前，构造 debug_df 并放进结果：

    equity_index = merged["datetime"]
    equity_series = pd.Series(equity_values, index=equity_index, name="equity")

    debug_df = pd.DataFrame(debug_rows)
    debug_df.set_index("datetime", inplace=True)

    return IctBacktestResult(
        trades=trades,
        equity=equity_series,
        config=config,
        debug=debug_df,
    )

二、UI 层：Streamlit 里展示调试表

在 ui/asset_lab_app.py 中，你现在大致是这样调用回测的：

res = run_ict_mtf_backtest(daily_bars, df, cfg_mtf)
st.subheader("ICT 多周期回测资金曲线")
_plot_equity_curve(res.equity)

2.1 加一个“显示调试明细”的开关

紧接着加：

show_debug = st.checkbox("显示调试明细（当前周期）", value=False)

if show_debug:
    debug_df = res.debug.copy()

    # 可选：加一个过滤选项
    view_mode = st.selectbox(
        "查看模式",
        ["全部bar", "只看有入场机会的bar", "只看实际开仓的bar", "只看平仓bar"],
        index=0,
    )

    if view_mode == "只看有入场机会的bar":
        debug_df = debug_df[(debug_df["can_open_long"]) | (debug_df["can_open_short"])]
    elif view_mode == "只看实际开仓的bar":
        debug_df = debug_df[(debug_df["opened_long"]) | (debug_df["opened_short"])]
    elif view_mode == "只看平仓bar":
        debug_df = debug_df[debug_df["closed_pos"]]

    st.write(f"共 {len(debug_df)} 行")
    st.dataframe(debug_df.tail(300))  # 最近300根，防止太大


这样：

你在 UI 上切换“日线 / 60 / 30 / 15 / 5 分钟”时，
run_ict_mtf_backtest 会针对当前周期重算一遍回测；

勾上“显示调试明细”，就能看到这个周期下每一根 K 的判断全过程；

如果你怀疑“为什么这儿没有开仓”，就用“只看有入场机会的 bar”看看，是不是 R:R 过滤掉了，还是 OB 没命中，还是根本没识别成反转 K 线。