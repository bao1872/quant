一、目标概述

围绕 stock_bollinger_data + 逐笔数据，构建一套完整的：

股性活跃选股池：

条件：近期曾 v_price_position > 99、曾 price_position > 50，代表放量+强势。

资金质量评估（日度）：

评价过去几天拉升是“高质量资金”还是“杂散资金”，用于在股池里排序、过滤。

关键价位（支撑/阻力）资金吸收分析：

对阿布价位 / 重要价位附近，统计大单吸筹/出货情况，判断真正的强支撑/重阻力。

最终策略：

只在：

股性活跃

资金质量高

下方有强支撑吸筹、上方无明显重阻力出货
的标的上找买点。

二、数据与新表设计
2.1 已有表（只引用）

stock_bollinger_data

字段（简化）：ts_code, trade_date, price_position, band_width_zscore, v_price_position, v_band_width_zscore, ...

stock_daily

ts_code, trade_date, open, high, low, close, vol, amount, ...

tick 数据 & 价位表

tick：逐笔（以你现有 parquet / 表为准）

abu_price_levels（或你现有的阿布价位表）

ts_code, trade_date / calc_date, level_price, level_type (support/resistance/flip), ...

2.2 新增一：股性活跃选股池表 stock_active_pool

作用：记录每天盘后筛出来的“活跃标的池”。

表结构建议：

stock_active_pool
-----------------
ts_code        VARCHAR
trade_date     DATE      -- 信号日期（T 日）
window_days    INT       -- 回看窗口，比如 20
has_high_vpos  BOOLEAN   -- 该窗口内是否出现 v_price_position > 99
has_high_ppos  BOOLEAN   -- 该窗口内是否出现 price_position > 50 or 70
max_vpos       FLOAT
max_ppos       FLOAT
avg_amount     NUMERIC   -- 窗口内日均成交额
remarks        TEXT      -- 预留
PRIMARY KEY (ts_code, trade_date)

2.3 新增二：日度微结构摘要 stock_microstructure_daily

作用：对每只股票、每天的逐笔成交做资金结构汇总，用于资金质量和后续分析。

表结构建议：

stock_microstructure_daily
--------------------------
ts_code           VARCHAR
trade_date        DATE
total_value       NUMERIC    -- 全日成交额
total_volume      BIGINT
vwap              NUMERIC    -- 全日 VWAP

big_buy_value     NUMERIC    -- 大单买入额
big_sell_value    NUMERIC    -- 大单卖出额
big_net_value     NUMERIC    -- 大单净额
big_net_ratio     NUMERIC    -- big_net_value / total_value
big_buy_ratio     NUMERIC    -- big_buy_value / total_value
big_sell_ratio    NUMERIC    -- big_sell_value / total_value

big_net_open      NUMERIC    -- 09:30-10:00
big_net_mid       NUMERIC    -- 10:00-14:00
big_net_close     NUMERIC    -- 14:00-15:00

order_flow_imbalance  NUMERIC  -- (主动买额 - 主动卖额) / 总成交额

created_at        TIMESTAMP
PRIMARY KEY (ts_code, trade_date)


大单阈值建议按 每只股票、最近 60 日 tick 的成交额 P90/P95 计算，可先写死一个阈值，后面再优化。

2.4 新增三：资金质量评分表 stock_fund_quality

作用：以“最近一段上涨窗口”为单位，对资金质量打分。

stock_fund_quality
------------------
ts_code              VARCHAR
window_start         DATE
window_end           DATE
window_days          INT

price_return         NUMERIC      -- 涨幅（close_end / close_start - 1）
big_net_sum          NUMERIC      -- 窗口大单净流入
turnover_ratio       NUMERIC      -- 窗口总成交额 / 自由流通市值

pos_days_ratio       NUMERIC      -- 大单净流入为正的天数占比
trend_corr           NUMERIC      -- 累计净流入 vs 收盘价的相关

big_cost_gain        NUMERIC      -- 成本区浮盈：close_end / big_buy_vwap - 1
support_ratio        NUMERIC      -- 回调段中大单净流入 >= 0 的比例

fund_quality_score   NUMERIC      -- 综合得分，0~1 或 z-score
created_at           TIMESTAMP

PRIMARY KEY (ts_code, window_end)

2.5 新增四：价位微结构表 stock_level_microstructure

作用：对每个关键价位、每次测试，统计资金吸收情况（支撑/阻力）。

stock_level_microstructure
--------------------------
ts_code          VARCHAR
trade_date       DATE
level_price      NUMERIC
level_type       VARCHAR   -- 'support' / 'resistance' / 'flip'
test_id          INT       -- 当日同一价位的第几次测试

band_pct         NUMERIC   -- 观察带宽相对比例
vol_total        BIGINT
value_total      NUMERIC

big_buy_value    NUMERIC
big_sell_value   NUMERIC
big_net_value    NUMERIC
big_net_ratio    NUMERIC

order_flow_imbalance NUMERIC

max_penetration  NUMERIC   -- 相对 level 的最大穿透幅度（support 用向下，resistance 用向上）
time_above_level_ratio  NUMERIC
time_below_level_ratio  NUMERIC

future_return_30m  NUMERIC
future_return_1d   NUMERIC

support_absorption_score_test         NUMERIC  -- 对 support type 有效
resistance_sell_absorption_score_test NUMERIC  -- 对 resistance type 有效
flip_support_score_test               NUMERIC  -- 对 flip type 回踩时

created_at       TIMESTAMP
PRIMARY KEY (ts_code, trade_date, level_price, test_id)

三、模块与函数设计

下面按照你项目风格，给出推荐的模块 / 函数。

3.1 股性活跃选股池（基于 stock_bollinger_data）

文件建议： factors/active_pool.py

核心函数：

def build_active_pool(trade_date: date, window_days: int = 20) -> None:
    """
    从 stock_bollinger_data 构建某日的股性活跃池，写入 stock_active_pool。
    条件：
      - 过去 window_days 内曾经 v_price_position > 99
      - 且曾经 price_position > 50 或 70
      - 过滤 ST、退市、日均成交额过低的票
    """


逻辑要点：

从 stock_bollinger_data 查询 [trade_date - window_days + 1, trade_date] 范围内数据；

group by ts_code：

max_vpos = max(v_price_position)

max_ppos = max(price_position)

avg_amount 从 stock_daily 聚合；

条件：

max_vpos > 99

max_ppos > 50（或 70，可配）

avg_amount > 某阈值（如 3000 万）

将满足条件的 ts_code 写入 stock_active_pool。

3.2 日度微结构摘要（逐笔 → stock_microstructure_daily）

文件建议： microstructure/daily_summary.py

3.2.1 逐笔增强 &单日指标
def summarize_microstructure_for_stock(
    ts_code: str,
    trade_date: date,
    big_trade_threshold: float,
) -> dict:
    """
    读取某只股票某一天的 tick 数据，计算:
      - total_value, total_volume, vwap
      - big_buy_value, big_sell_value, big_net_value, big_net_ratio
      - big_net_open/mid/close
      - order_flow_imbalance
    返回字典，后续写库。
    """


要点：

从 TickStore 或 tick 表读出该日 tick；

为每条成交打上：

trade_value = price * volume

side（主动买/卖）——用你已有逻辑；

time_bucket（09:30–10:00 / 10:00–14:00 / 14:00–15:00）；

根据 big_trade_threshold 判断大单；

按上面表结构聚合。

3.2.2 批量任务（对股池）
def build_microstructure_daily(trade_date: date, only_active_pool: bool = True) -> None:
    """
    对 trade_date 的股票，批量生成 daily microstructure，写入 stock_microstructure_daily。
    默认只对 stock_active_pool 里的股票处理。
    """

3.3 资金质量评分（stock_fund_quality）

文件建议： microstructure/fund_quality.py

3.3.1 确定上涨窗口
def detect_rise_window(ts_code: str, trade_date: date, max_lookback: int = 20) -> tuple[date, date]:
    """
    从 stock_daily / stock_bollinger_data 中，识别出以 trade_date 为末日的
    最近一段“上涨窗口”[window_start, trade_date]。
    简化版可以用：
      - close_trade_date > close_{trade_date-k}
      - 中间最大回撤 < 某阈值
    """

3.3.2 在窗口上计算资金质量
def compute_fund_quality_for_window(
    ts_code: str,
    window_start: date,
    window_end: date,
) -> dict:
    """
    从 stock_microstructure_daily + stock_daily + basic 表读取数据，计算：
      - price_return, big_net_sum, turnover_ratio
      - pos_days_ratio, trend_corr
      - big_cost_gain（大单成本区浮盈）
      - support_ratio（回调段中大单净流入 >= 0 的比例）
      - fund_quality_score（按权重综合）
    返回字典。
    """


具体指标实现参考：

price_return = close_end / close_start - 1

big_net_sum = Σ big_net_value_d

turnover_ratio = Σ total_value_d / free_float_value

pos_days_ratio = (big_net_value_d > 0 的天数) / 窗口长度

trend_corr：对 [累计 big_net_value_d] 和 close_d 做相关系数

big_buy_vwap：窗口内所有大买单的加权价；
big_cost_gain = close_end / big_buy_vwap - 1

support_ratio：在窗口内所有“回调段”中，big_net_pullback >= 0 的段数比率
（回调段可以先简单定义为连续多日收盘回落 2%～4% 的片段）

fund_quality_score：

先对上述指标做标准化（在同一日或滚动窗口内），再用权重线性组合。

3.3.3 批量任务
def build_fund_quality(trade_date: date) -> None:
    """
    对 trade_date 当天 stock_active_pool 中的每只标的：
      1）识别上涨窗口
      2）计算资金质量指标
      3）写入 stock_fund_quality
    """

3.4 价位资金吸收（stock_level_microstructure）

文件建议： microstructure/level_absorption.py

3.4.1 对单个价位、单次测试做分析
def analyze_level_absorption_for_test(
    ticks: pd.DataFrame,
    level_price: float,
    level_type: str,
    band_pct: float = 0.005,
    future_horizon_minutes: int = 30,
) -> dict:
    """
    针对某只股票某日 tick 中的一次“价位测试”，计算：
      - vol_total, value_total
      - big_buy_value / big_sell_value / big_net_value / big_net_ratio
      - order_flow_imbalance
      - max_penetration（最大穿透幅）
      - time_above_level_ratio / time_below_level_ratio
      - future_return_30m, future_return_1d
      - support_absorption_score_test / resistance_sell_absorption_score_test / flip_support_score_test
    """


处理流程：

确定观察带：
[L*(1-band_pct), L*(1+band_pct)]；

识别“测试片段”：

价格从带外进入→在带内停留→离开带内

给每个片段一个 test_id；

对每个片段在带内的 tick 做聚合，计算上述字段；

分别按 level_type 推出对应 score（公式参考你前面认同的那套）：

支撑吸收：大单净买 + 不被深穿 + 后续反弹；

阻力卖出吸收：大单净卖 + 多次冲不过 + 后续回落；

flip 支撑：阻力上方变为支撑后的回踩吸筹质量。

3.4.2 批量处理（某标的一天）
def build_level_microstructure_for_stock(
    ts_code: str,
    trade_date: date,
    band_pct: float = 0.005,
) -> None:
    """
    读取：
      - 当日 tick
      - 当日或最近一次的阿布价位（abu_price_levels）
    对每个 level, 对所有测试片段调用 analyze_level_absorption_for_test，
    并写入 stock_level_microstructure。
    """

3.4.3 全市场任务（可只对活跃池）
def build_level_microstructure(trade_date: date) -> None:
    """
    对 trade_date 的股票（建议只对 active_pool + 有 Abu 价位的票）批量执行。
    """

四、策略层设计（选股+择时）

文件建议： strategy/strategy_bollinger_microstructure.py

4.1 选股（盘后）

选股逻辑（T 日盘后）：

从以下表 join：

stock_active_pool（T 日）

stock_fund_quality（以 window_end <= T 的最近一条）

stock_level_microstructure（最近 N 日统计）

筛选条件示例：

股性活跃：

stock_active_pool 里存在；

资金质量：

fund_quality_score 在当日所有候选中处于前 30%；

支撑吸筹：

下方某个主要支撑位（如最近的阿布支撑）
support_absorption_score_L 在历史分位数 Top 30%，
并且当前收盘价距离该支撑位不太远。

阻力压制不强：

上方最近主要阻力位的 resistance_sell_absorption_score_L 不高；

或已翻转为 flip 支撑，且 flip_support_score_L 高。

输出：
T+1 观察 + 允许建仓的 候选列表，包含：

ts_code

理想支撑价位（买点参考）

资金质量分数 & 支撑/阻力情况。

4.2 择时 & 交易规则（框架）

可以先在日线回测层实现简单版本：

入场（T+1）：

若 T+1 日开盘价在支撑位附近（比如 |open - L| / L < 0.5%），则按开盘价建仓；

或在 T+1 日低价不跌破支撑位太多、收盘在 L 上方则以收盘价建仓。

止盈：

第一档：价格回到布林中轨 price_position >= 50 卖一半；

第二档：价格接近上轨 price_position >= 80 或上方阻力位附近全部卖出。

止损：

跌破支撑位一定比例（如 1–2%）+ 当日支撑位附近 big_net_ratio < 0、order_flow_imbalance << 0 → 止损；

或固定 -5% + 时间止损（超过 10 日未触达中轨）。

后续可以在 tick 回测引擎中实现更精细的 “在支撑带内看逐笔实时吸筹再决策”。

五、调度与运行流程（APScheduler）

在你现有 scheduler 中加一个盘后任务链：

def run_post_close_jobs(trade_date: date | None = None) -> None:
    d = trade_date or get_latest_trading_date()

    # 1. 更新日线 & 布林表（你已经有）
    job_update_ohlc(d)
    job_update_bollinger(d)

    # 2. 构建股性活跃池
    build_active_pool(d)

    # 3. 对活跃池生成日度微结构摘要
    build_microstructure_daily(d, only_active_pool=True)

    # 4. 对活跃池计算资金质量
    build_fund_quality(d)

    # 5. 对活跃池 + 有阿布价位的票构建价位微结构
    build_level_microstructure(d)

    # 6. 生成 T+1 策略候选股票列表（可以落库或输出到某表）
    build_strategy_candidates(d)

六、建议的开发顺序（可分阶段）

阶段 1：股池 & 日度微结构

实现 build_active_pool；

实现 stock_microstructure_daily 相关代码；

检查日度指标是否合理。

阶段 2：资金质量评分

实现上涨窗口识别；

实现 stock_fund_quality；

做简单统计：资金质量高 vs 低 的未来收益分布。

阶段 3：价位吸收分析

实现 stock_level_microstructure；

对典型案例（肉眼见的支撑/阻力）做 sanity check。

阶段 4：策略实现 & 回测

写 strategy_bollinger_microstructure.py；

在日线回测框架里先跑穿。

阶段 5：前端 UI & 实盘观察

Streamlit 增加：

资金质量分数 + 价位吸收可视化；

某只股票近期关键价位附近的大单行为。